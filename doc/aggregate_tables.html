<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Optimizing the performance of a Mondrian database</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css" />
</head>

<body>

<h1>Aggregate Tables</h1>

<p>By Richard Emberson; last updated by Julian Hyde, July, 2005.</p>

<hr noshade color="#000000" size="1">

<h2>Contents</h2>
  <ul>
	<li><a href="#Introduction">Introduction</a></li>
	<li><a href="#What_are_aggregates">What are aggregate tables?</a><ol>
		<li><a href="#A_simple_aggregate_table">A simple aggregate table</a></li>
		<li><a href="#Another_aggregate_table">Another aggregate table</a></li>
	</ol></li>
	<li><a href="#Defining_aggregate_tables">Defining aggregate tables</a></li>
	<li><a href="#Building_aggregates">Building aggregate tables</a></li>
	<li><a href="#How_Mondrian_recognizes_Aggregate_Tables">How Mondrian 
	recognizes aggregate tables</a><ol>
		<li><a href="#Recognizing_default">Rules</a></li>
		<li><a href="#Recognizing_explicit">Explicit aggregates</a></li>
	</ol></li>
	<li><a href="#How_Mondrian_uses_aggregate_tables">How Mondrian uses 
	aggregate tables</a></li>
	<li><a href="#Tools_for_designing_and_maintaining_aggregate_tables">Tools 
		for designing and maintaining aggregate tables</a><ul>
		<li><a href="#AggGen_aggregate_generator">AggGen (aggregate generator)</a></li>
		<li><a href="#Aggregate_table_populater">Aggregate table populater</a></li>
		<li><a href="#Script_generator">Script generator</a></li>
		<li><a href="#Recommender">Recommender</a></li>
		<li><a href="#Online_offline_control">Online/offline control</a></li>
	</ul>
	<li><a href="#Aggregate_properties">Properties which affect aggregates</a><li>
	<a href="#References">References</a></ul>

<h2><a name="Introduction">Introduction</a></h2>
<p>
Unlike many OLAP servers, Mondrian does not store data on disk: it just works on 
the data in the RDBMS, and once it has read a piece of data once, it stores that 
data in its cache. This greatly simplifies the process of installing Mondrian, 
but it puts limits on Mondrian's performance when Mondrian is applied to a huge 
dataset.&nbsp;
</p>

<p>
Consider what happens when the CEO runs her Sales Report first thing on a Monday 
morning. This report contains a single number: the total sales of all products, 
in all regions, this year. In order to get this number, Mondrian generates a 
query something like this:</p>

<blockquote>

	<p><code>SELECT sum(store_sales)<br>
	FROM sales_fact, <br>
&nbsp;&nbsp;&nbsp; time<br>
	WHERE sales_fact.time_id = time.time_id<br>
	AND time.year = 2005</code></p>
</blockquote>

<p>
and sends it to the DBMS. The DBMS takes several minutes to execute it: which is 
understandable because the DBMS has to read all of this year's records in the 
fact table (a few million sales, say) and aggregate them into a single total. 
Clearly, what is needed in this case, and in others like it, is a pre-computed 
summary of the data: an aggregate table.</p>

<p>
An <dfn><font face="Verdana">aggregate table</font></dfn> coexists with the base fact table, 
and contains pre-aggregated measures build from the 
fact table. It is registered in Mondrian's schema, so that Mondrian can choose 
to use whether to use the aggregate table rather than the fact table, if it is 
applicable for a particular query.</p>

<p>
Designing aggregate tables is a fine art.
There is extensive research, both empirical and theoretical, available
on the web concerning different ways to structure aggregate tables and we will not attempt to duplicate any of it here.
</p>
<h2><a name="What_are_aggregates">What are aggregate tables?</a></h2>

<p>To explain what aggregate tables are, let's consider a simple star schema.</p>

<blockquote>

	<p><img border="0" src="aggregate_tables_1.png"></p>
</blockquote>

<p>The star schema has a single fact table <code>Sales</code>, two measure 
columns (<code>units</code> and <code>dollars</code>) and four dimension tables 
(<code>Product</code>, <code>Mfr</code>, <code>Customer</code>, <code>Time</code>, 
and <code>Customer</code>).</p>

<p>On top of this star schema, we create the following multidimensional model:</p>
<ul>
	<li>Cube <code>[Sales]</code> has two measures <code>[Unit sales]</code> and
	<code>[Dollar sales]</code></li>
	<li>Dimension <code>[Product]</code> has levels <code>[All Products]</code>,
	<code>[Manufacturer]</code>, <code>[Brand]</code>, <code>[Prodid]</code></li>
	<li>Dimension <code>[Time]</code> has levels <code>[All Time]</code>, <code>
	[Year]</code>, <code>[Quarter]</code>, <code>[Month]</code>, <code>[Day]</code></li>
	<li>Dimension <code>[Customer]</code> has levels <code>[All Customers]</code>,
	<code>[State]</code>, <code>[City]</code>, <code>[Custid]</code></li>
	<li>Dimension <code>[Payment Method]</code> has levels <code>[All Payment 
	Methods]</code>, <code>[Payment Method]</code></li>
</ul>

<p>Note that the <code>[Product]</code> dimension is a 'snowflake dimension' 
(that is, it is spread across two tables <code>Product</code> and <code>Mfr</code>) 
and the <code>[Payment Method]</code> dimension is contained within the <code>
payment</code> column in the fact table.</p>

<h3><a name="A_simple_aggregate_table">A simple aggregate table</a></h3>

<p>Now let's create an aggregate table, <code>Agg_1</code>:</p>

<blockquote>

	<p><img border="0" src="aggregate_tables_2.png" width="417" height="172"></p>
</blockquote>

<p>See how the original star schema columns have been combined into the table:</p>
<ul>
	<li>The <code>Time</code> dimension has been &quot;collapsed&quot; into the aggregate 
	table, omitting the <code>month</code> and <code>day</code> columns.</li>
	<li>The two tables of the <code>Product</code> dimension has been 
	&quot;collapsed&quot; into the aggregate table.</li>
	<li>The Customer dimension has been &quot;lost&quot;.</li>
	<li>For each measure column in the fact table (<code>units</code>, <code>dollars</code>), 
	there are one or more measure columns in the aggregate table (<code>sum units</code>, <code>min 
	units</code>, <code>max units</code>, <code>sum dollars</code>).</li>
	<li>There is also a measure column, <code>row count</code>, representing the 
	&quot;count&quot; measure.</li>
</ul>

<p><code>Agg_1</code> would be declared like this:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
	&nbsp;&nbsp;&lt;<a href="#XML_Table">Table</a> name=&quot;sales&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggName">AggName</a> 
	name=&quot;agg_1&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggFactCount">AggFactCount</a> column=&quot;row count&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Unit 
	Sales]&quot; column=&quot;sum units&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> 
	name=&quot;[Measures].[Min Units]&quot; column=&quot;min units&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Max 
	Units]&quot; column=&quot;max units&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Dollar 
	Sales]&quot; column=&quot;sum dollars&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Year]&quot; 
	column=&quot;year&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Quarter]&quot; 
	column=&quot;quarter&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Product].[Mfrid]&quot; 
	column=&quot;mfrid&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Product].[Brand]&quot; 
	column=&quot;brand&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Product].[Prodid]&quot; 
	column=&quot;prodid&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_AggName">AggName</a>&gt;<br>
	&nbsp;&nbsp;&lt;/<a href="#XML_Table">Table</a>&gt;<br>
	&nbsp;<br>
	&nbsp;&nbsp;&lt;!-- Rest of the cube definition --&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>

<h3><a name="Another_aggregate_table">Another aggregate table</a></h3>

<p>Another aggregate table, <code>Agg_2</code>:</p>

<blockquote>

	<p><img border="0" src="aggregate_tables_3.png"></p>
</blockquote>

<p>and the corresponding XML:</p>

<blockquote>

	<p><code>&lt;<a href="#XML_Cube">Cube</a> name=&quot;Sales&quot;&gt;<br>
	&nbsp;&nbsp;&lt;<a href="#XML_Table">Table</a> name=&quot;sales&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggName">AggName</a> 
	name=&quot;agg_1&quot; ... /&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggName">AggName</a> 
	name=&quot;agg_2&quot;&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggFactCount">AggFactCount</a> column=&quot;row count&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggForeignKey">AggForeignKey</a> factColumn=&quot;prodid&quot; 
	aggColumn=&quot;prodid&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Unit 
	Sales]&quot; column=&quot;sum units&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> 
	name=&quot;[Measures].[Min Units]&quot; column=&quot;min units&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Max 
	Units]&quot; column=&quot;max units&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggMeasure">AggMeasure</a> name=&quot;[Measures].[Dollar 
	Sales]&quot; column=&quot;sum dollars&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Year]&quot; 
	column=&quot;year&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Quarter]&quot; 
	column=&quot;quarter&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Time].[Month]&quot; 
	column=&quot;month&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Payment 
	Method].[Payment Method]&quot; 
	column=&quot;payment&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="#XML_AggLevel">AggLevel</a> name=&quot;[Customer].[State]&quot; 
	column=&quot;state&quot;/&gt;<br>
	&nbsp;&nbsp;&nbsp; &lt;/<a href="#XML_AggName">AggName</a>&gt;<br>
	&nbsp;&nbsp;&lt;/<a href="#XML_Table">Table</a>&gt;<br>
	<br>
&nbsp; &lt;<a href="schema.html#XML_Dimension">Dimension</a> name=&quot;Product&quot;&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Hierarchy">Hierarchy</a> hasAll=&quot;true&quot; 
	primaryKey=&quot;prodid&quot; primaryKeyTable=&quot;Product&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Join">Join</a> leftKey=&quot;mfrid&quot; 
	rightKey=&quot;mfrid&quot;&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Table">Table</a> 
	name=&quot;Product&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Table">Table</a> 
	name=&quot;Mfr&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/<a href="schema.html#XML_Join">Join</a>&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Level">Level</a> 
	name=&quot;Manufacturer&quot; table=&quot;Mfr&quot; column=&quot;mfrid&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Level">Level</a> 
	name=&quot;Brand&quot; table=&quot;Product&quot; column=&quot;brand&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;<a href="schema.html#XML_Level">Level</a> 
	name=&quot;Name&quot; table=&quot;Product&quot; column=&quot;prodid&quot;/&gt;<br>
&nbsp;&nbsp;&nbsp; &lt;/<a href="schema.html#XML_Hierarchy">Hierarchy</a>&gt;<br>
&nbsp; &lt;/<a href="schema.html#XML_Dimension">Dimension</a>&gt;<br>
	<br>
	&nbsp;&nbsp;&lt;!-- Rest of the cube definition --&gt;<br>
	&lt;/<a href="#XML_Cube">Cube</a>&gt;</code></p>
</blockquote>

<p>Several dimensions have been collapsed: <code>[Time]</code> at the <code>
[Quarter]</code> level; <code>[Customer]</code> at the <code>[State]</code> 
level; and <code>[Payment Method]</code> at the <code>[Payment Method]</code> 
level. But the <code>[Product]</code> dimension has been retained in its 
original snowflake form.</p>

<p>The <code>&lt;<a href="#XML_AggForeignKey">AggForeignKey</a>&gt;</code> element is 
used to&nbsp; declare that the column <code>prodid</code> links to the dimension 
table, but all other columns remain in the <code>Product</code> and <code>Mfr</code> 
dimension tables.</p>

<h2><a name="Defining_aggregate_tables">Defining aggregate tables</a></h2>
<p>
A fact table can have zero or more aggregate tables.
Every aggregate table is associated with just one fact table.
It aggregates the fact table measures over one or more of the dimensions.
As an example, if a particular column in the fact table represents the
number of sales of some product on a given day by a given store, then
an aggregate table might be created that sums the information so that
applies at a month level rather than by day. Such an aggregate might
reasonably be 1/30<sup><font face="Verdana">th</font></sup> the size of the fact table (assuming comparable sales
for every day of a month). Now, if one were to execute a MDX query
that needed sales information at a month (or quarter or year) level,
running the query against the aggregate table is faster but yields the
same answer as if it were run against the base fact table.</p>
<p>
Further, one might create an aggregate that not only aggregates at the month
level but also, rather than at the individual store level, aggregates at
the state level. If there were, say, 20 stores per state, then this
aggregate table would be 1/600<sup><font face="Verdana">th</font></sup> the size of the original fact table. MDX queries interested only at the month or above and state or above levels
would use this table.
</p>
<p>
When a MDX query runs, what aggregate should be used?
This comes down to what measures are needed and with which dimension levels.
The base fact table always has the correct measures and dimension
levels. But, it might also be true that there is one or more aggregate
tables that also have the measures and levels. Of these, the aggregate
table with the lowest cost to read, the smallest number of rows,
should be the table used to fulfill the query.
</p>
<p>
Mondrian supports two aggregation techniques which are called "lost"
dimension and "collapsed" dimension. For the creation of any
given aggregate table these can 
be applied independently to any number of different dimensions.
</p>
<p>
A "lost" dimension is one which is completely missing from the aggregate
table. The measures that appear in the table have been aggregated 
across all values of the lost dimension. As an example, in a fact table
with dimensions of time, location, and product and measure sales, for an
aggregate table that did not have the location dimension that
dimension would be "lost". Here, the sales measure would be the aggregation
over all locations. An aggregate table where all of the dimensions
are lost is possible - it would have a single row with the measure 
aggregated over everything - sales for all time, all locations and all
products.
</p>
<code>
<blockquote>
<pre>
fact table
    time_id
    product_id
    location_id
    measure

lost (time_id) dimension table
    product_id
    location_id
    measure (aggregated over time)
    fact_count

fully lost dimension table
    measure (aggregated over everything)
    fact_count
</pre>
</blockquote>
</code>
<p>
Note the "fact_count" column in the aggregate table. This additional
column is a general feature of aggregate tables. It is a count of
how many fact table columns were aggregated into the one aggregate
table row. As an example, if for a particular choice of product_id and
location_id, the time_id occurred 5 times in the fact table, then in the
aggregate table the fact_count column would contain 5 for that
product_id/location_id pair (a given product was sold at a given
location at 5 different times).
</p>
<p>
The second supported aggregation technique provides a finer level of 
control, the "collapsed" dimension technique.
Recall that the dimension key in the fact table refers (more or less) 
to the 
lowest level in the dimension hierarchy.
For a collapsed dimension, the dimension key in the aggregate
table is replaced with a set of dimension levels; the dimension key
column is replaced with a set of columns; a fully denormalized
summary table for that dimension.
As an example, if the time dimension with base fact table foreign key 
time_id had the levels: day, month, quarter and
year, and in an aggregate it was collapsed to the month level, then
the aggregate table would not have a time_id column but rather
columns for month, quarter and year. The SQL generated for a
MDX query for which this aggregate table can be used, would no longer
refer to the time dimension's table but rather all time related
information would be gotten from the aggregate table.
</p>
<code>
<blockquote>
<pre>
time dimension table
    time_id
    day
    month
    quarter
    year

fact table
    time_id
    measure

collapsed dimension table
    month
    quarter
    year
    measure (aggregated to month level)
    fact_count
</pre>
</blockquote>
</code>
<p>
In the literature, there are other ways of creating aggregate tables
but they are not supported by Mondrian at this time.
</p>
<h2><a name="Building_aggregates">Building aggregate tables</a></h2>
<p>
Aggregate tables must be built.
Generally, they not real-time; they are rebuilt,
for example, every night for use the following day by the analysts.
Considering the lost and collapsed dimension technique for
aggregate table definition, one can estimate that for a dimension
with N levels, there are N+1 possible aggregate tables (N collapsed and
1 lost). Also, dimensions (with different dimension tables) can
be aggregated independently. 
For the FoodMart Sales cube there are 1400 different possible aggregate 
tables.
</p>
<p>
Clearly, one does not want to create all possible aggregate tables.
Which ones to create depends upon two considerations. The first
consideration is application dependent: 
the nature of the MDX queries that will be executed.
If many of the queries deal with per month and per state questions,
then an aggregate at those levels might be created.
The second consideration is application independent: per
dimension aggregating from
the lowest level to the next lowest generally gives greater
bang for the buck than aggregating from the N to the N+1 (N&gt;1) level.
This is because 1) a first level aggregation can be used for all
queries at that level and above and 2) dimension fanout tends to 
increase for the lower levels.
Of course, your mileage may vary.
</p>
<p>
In a sense, picking which aggregate tables to build is analogous to 
picking which indexes to build on a table; it is application
dependent and experience helps.
</p>
<p>
The hardest part about the actually creation and population of 
aggregate tables is figuring out how to create the first couple;
what the SQL looks like.
After that they are pretty much all the same.
</p>
<p>
Four examples will be given. They all concern building
aggregate tables for the sales_fact_1997 fact table.
As a reminder, the sales_fact_1997 fact table looks like:
</p>
<code>
<blockquote>
<pre>
sales_fact_1997
    product_id 
    time_id 
    customer_id 
    promotion_id
    store_id
    store_sales
    store_cost
    unit_sales
</pre>
</blockquote>
</code>
<p>
The first example is a lost time dimension aggregate table, the
time_id foreign key is missing.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_l_05_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    promotion_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL);

CREATE INDEX i_sls_97_cust_id ON agg_l_05_sales_fact_1997 (customer_id);
CREATE INDEX i_sls_97_prod_id ON agg_l_05_sales_fact_1997 (product_id);
CREATE INDEX i_sls_97_promo_id ON agg_l_05_sales_fact_1997 (promotion_id);
CREATE INDEX i_sls_97_store_id ON agg_l_05_sales_fact_1997 (store_id);

INSERT INTO agg_l_05_sales_fact_1997 (
    product_id,
    customer_id,
    promotion_id,
    store_id,
    store_sales,
    store_cost,
    unit_sales,
    fact_count)
SELECT
    product_id,
    customer_id,
    promotion_id,
    store_id,
    SUM(store_sales) AS store_sales,
    SUM(store_cost) AS store_cost,
    SUM(unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM 
    sales_fact_1997 
GROUP BY 
    product_id, 
    customer_id, 
    promotion_id, 
    store_id;
</pre>
</blockquote>
</code>
<p>
A couple of things to note here. 
</p>
<p>
The above is in MySQL's dialect of SQL, and may
not work for your database - but I hope the general idea is clear.
The aggregate table "looks like" the base fact table except the
time_id column is missing and there is a new fact_count column.
The insert statement populates the aggregate table from the base fact
table summing the measure columns and counting to populate the
fact_count column. This done while grouping by the remaining
foreign keys to the remaining dimension tables.
</p>
<p>
Next, some databases recognize star joins - Oracle for instance.
For such database one should not create indexes, not on the fact table
and not on the aggregate tables. On the other hand, databases that
do not recognize star joins will require indexes on both the
fact table and the aggregate tables.
</p>
<p>
For our purposes here, the exact name of the aggregate table is not 
important; the "agg_l_05_" preceding the base fact table's name
sales_fact_1997. First, the aggregate table name must be different
from the base fact table name. Next, the aggregate table name ought to be 
related to the base fact table name both for human eyeballing of what
aggregate is associated with which fact table, but also, as described
below, Mondrian employs mechanism to automagically recognize which
tables are aggregates of others.
</p>
<p>
The following example is a collapsed dimension aggregate table 
where the time dimension has been rolled up to the month level.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_c_14_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    promotion_id INTEGER NOT NULL,
    store_id INTEGER NOT NULL,
    month_of_year SMALLINT(6) NOT NULL,
    quarter VARCHAR(30) NOT NULL,
    the_year SMALLINT(6) NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL);

CREATE INDEX i_sls_97_cust_id ON agg_c_14_sales_fact_1997 (customer_id);
CREATE INDEX i_sls_97_prod_id ON agg_c_14_sales_fact_1997 (product_id);
CREATE INDEX i_sls_97_promo_id ON agg_c_14_sales_fact_1997 (promotion_id);
CREATE INDEX i_sls_97_store_id ON agg_c_14_sales_fact_1997 (store_id);

INSERT INTO agg_c_14_sales_fact_1997 (
    product_id,
    customer_id,
    promotion_id,
    store_id,
    month_of_year,
    quarter,
    the_year,
    store_sales,
    store_cost,
    unit_sales,
    fact_count)
SELECT
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS store_sales,
    SUM(BASE.store_cost) AS store_cost,
    SUM(BASE.unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM 
    sales_fact_1997 AS BASE, time_by_day AS DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
In this case, one can see that the time_id foreign key in the base
fact table has been replaced with the columns: month_of_year, quarter,
and the_year in the aggregate table. There is, as always, the fact_count
column. The measures are inserted as sums. And, the group by clause
is over the remaining foreign keys as well as the imported time
dimension levels.
</p>
<p>
When creating a collapsed dimension aggregate one might consider creating
indexes for the columns imported from the dimension that was collapsed.
</p>
<p>
Below is another aggregate table. This one has two lost dimensions (<code>store_id</code> and 
<code>promotion_id</code>) as well as collapsed dimension on time
to the quarter level. This shows how aggregate techniques can be
mixed.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_lc_100_sales_fact_1997 (
    product_id INTEGER NOT NULL,
    customer_id INTEGER NOT NULL,
    quarter VARCHAR(30) NOT NULL,
    the_year SMALLINT(6) NOT NULL,
    store_sales DECIMAL(10,4) NOT NULL,
    store_cost DECIMAL(10,4) NOT NULL,
    unit_sales DECIMAL(10,4) NOT NULL,
    fact_count INTEGER NOT NULL);

CREATE INDEX i_sls_97_cust_id ON agg_lc_100_sales_fact_1997 (customer_id);
CREATE INDEX i_sls_97_prod_id ON agg_lc_100_sales_fact_1997 (product_id);

INSERT INTO agg_lc_100_sales_fact_1997 (
    product_id,
    customer_id,
    quarter,
    the_year,
    store_sales,
    store_cost,
    unit_sales,
    fact_count)
SELECT
    BASE.product_id,
    BASE.customer_id,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS store_sales,
    SUM(BASE.store_cost) AS store_cost,
    SUM(BASE.unit_sales) AS unit_sales,
    COUNT(*) AS fact_count
FROM sales_fact_1997 AS BASE,
    time_by_day AS DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
In the above three examples, for the most part the column names
in the aggregate are the same column names that appear in the fact 
table and dimension tables. These tables would all be
recognized by the Mondrian 
<a href="#Recognizing_default">default</a>
aggregate recognizer.
It is possible to create an aggregate table and name the columns arbitrarily.
For such an aggregate, an
<a href="#Recognizing_explicit">explicit</a>
Mondrian recognizer must be specified.
</p>
<code>
<blockquote>
<pre>
CREATE TABLE agg_c_special_sales_fact_1997 (
    PRODUCT_ID INTEGER NOT NULL,
    CUSTOMER_ID INTEGER NOT NULL,
    PROMOTION_ID INTEGER NOT NULL,
    STORE_ID INTEGER NOT NULL,
    TIME_MONTH SMALLINT(6) NOT NULL,
    TIME_QUARTER VARCHAR(30) NOT NULL,
    TIME_YEAR SMALLINT(6) NOT NULL,
    STORE_SALES_SUM DECIMAL(10,4) NOT NULL,
    STORE_COST_SUM DECIMAL(10,4) NOT NULL,
    UNIT_SALES_SUM DECIMAL(10,4) NOT NULL,
    FACT_COUNT INTEGER NOT NULL);

CREATE INDEX i_sls_97_cust_id ON agg_c_special_sales_fact_1997 (CUSTOMER_ID);
CREATE INDEX i_sls_97_prod_id ON agg_c_special_sales_fact_1997 (PRODUCT_ID);
CREATE INDEX i_sls_97_promo_id ON agg_c_special_sales_fact_1997 (PROMOTION_ID);
CREATE INDEX i_sls_97_store_id ON agg_c_special_sales_fact_1997 (STORE_ID);

INSERT INTO agg_c_special_sales_fact_1997 (
    PRODUCT_ID,
    CUSTOMER_ID,
    PROMOTION_ID,
    STORE_ID,
    TIME_MONTH,
    TIME_QUARTER,
    TIME_YEAR,
    STORE_SALES_SUM,
    STORE_COST_SUM,
    UNIT_SALES_SUM,
    FACT_COUNT)
SELECT
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year,
    SUM(BASE.store_sales) AS STORE_SALES_SUM,
    SUM(BASE.store_cost) AS STORE_COST_SUM,
    SUM(BASE.unit_sales) AS UNIT_SALES_SUM,
    COUNT(*) AS FACT_COUNT
FROM 
    sales_fact_1997 BASE, time_by_day DIM
WHERE
    BASE.time_id = DIM.time_id
GROUP BY 
    BASE.product_id,
    BASE.customer_id,
    BASE.promotion_id,
    BASE.store_id,
    DIM.month_of_year,
    DIM.quarter,
    DIM.the_year;
</pre>
</blockquote>
</code>
<p>
This aggregate table has column names that are not identical to those
found in the base fact table and dimension table. It is still a 
valid aggregate but Mondrian has to be told how to map its columns
into those of the base fact table.
</p>
<p>
Sometimes with multiple aggregate tables, one aggregate table is
an aggregate of not only the base fact table but also another
aggregate table; an aggregate table with lost time and product
dimensions (no time_id and product_id foreign keys)
is an aggregate of the base fact table and an aggregate which only
has a lost time dimension (no time_id foreign key).
In this case, one might first build the aggregate with only the
lost time dimension and then build the aggregate with both lost
time and product dimensions from that first aggregate - it will be
faster (in some cases, much faster) 
to populate the second aggregate from the first rather than
from the base fact table.
</p>
<p>
One last note, when creating aggregate tables from the base fact table
pay attention to the size of the numeric columns - what might be big
enough in the base fact table might not be big enough in an aggregate.
</p>
<h2><a name="How_Mondrian_recognizes_Aggregate_Tables">How Mondrian recognizes Aggregate 
Tables</a></h2>
<p>
Mondrian has to know about the aggregate tables in order to use them.
You can either define an aggregate explicitly, or set up rules to recognize 
several aggregate tables at the same time. 
</p>
<p>
How Mondrian recognizes aggregate table
names and columns pretty much dictates how one must name those
table names and columns when creating them in the first place!
</p>

<h3><a name="Recognizing_default">Rules</a></h3>
<p>
Rules are templates, designed to work for all fact table names 
and their column
names. 
These rules are templates of regular expressions 
that are instantiated with the names of a fact table
and its columns. In order to describe the rule templates, a name that
instantiate a rule are represented in a rule by have the name bracketed
by "${" and "}". As an example, 
"abc_${name}_xyz" 
is a rule parameterized
by "name". When name is "john" the template becomes 
"abc_john_xyz".
</p>
<p>
The regular expression engine used here and a definition of
the allowed regular expression grammar is found in
the Java regular expression Pattern class:
<a href=" http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern.</a>
</p>
<p>
In order that a table be recognized as an aggregate table, Mondrian
must be able to map from the fact table foreign key columns and measure
columns and those in the aggregate table. In addition, Mondrian
must identify the
fact count column in the aggregate and possible level columns (which
would appear in an aggregate table if it had a "collapsed" dimension).
What follows is a description of the steps taken in the identification
of aggregate tables by the default recognizer.
If at any step, a match fails, the table is rejected as an aggregate
table.
</p>
<p>
Starting off, the candidate aggregate table's name must comply with
the aggregate table name rule. Represented as a template regular
expression the rule is:
</p>
<blockquote>
    <code>agg_.+_${fact_table_name}</code></blockquote>
<p>
which is parameterized with the fact table's name.
(In addition, this rule is applied in "ignore case" mode.)
This means that an aggregate table's name must start with
"agg_" (ignoring character case), followed by at least one
character, then the '_' character and, lastly, the name of
the fact table. The ".+" in the template has special meaning
in a regular expression - it matches one or more characters.
</p>
<p>
As an example of applying the aggregate table name rule,
let the fact table be called 
<code>
sales_fact_1997
</code>, the 
<code>
Sales
</code>
cube's fact table from the FoodMart schema. Applying the
specific fact table name to the regular expression template
creates the following regular expression:
</p>
<blockquote>
    <code>agg_.+_sales_fact_1997</code></blockquote>
<p>
This will match the following table names:
</p>
<ul>
	<li><code>agg_l_05_sales_fact_1997</code></li>
	<li><code>agg_c_14_sales_fact_1997</code></li>
	<li><code>agg_lc_100_sales_fact_1997</code></li>
	<li><code>agg_c_special_sales_fact_1997</code></li>
	<li><code>AGG_45_SALES_FACT_1997</code></li>
	<li><code>AGG_drop_time_id_sales_fact_1997</code><br></li>
</ul>
<p>
The aggregate table name recognition mechanism has one additional
programatic feature, one can specify that only a portion of the
base fact table name be used as the basis of template name.
For instance, if the DBA demanded that all fact tables begin with the
string "fact_", e.g., 
"fact_sales_fact_1997",
one would certainly not want that string to have to
be part of each aggregate table's name. The aggregate table name
recognition mechanism allows one to specify a regular expression with
one and only one group clause (a group clause is a pattern bracketed 
by '(' and ')'). Whatever is matched by the contents of the
group clause is taken to be the part of the fact table name to be
used in the matching template. This regular expression containing the
group clause is specified as the "basename" attribute.
The default Mondrian aggregate table recognizer does not use this feature.
For more information see the associated 
<a href="developer_notes.html">developer's note link.</a>
</p>
<p>
After the default recognizer determines that a table's name matches
the aggregate table template regular expression for a given
fact table, it then attempts to match columns. The first column
tested for is the "fact count" column. Here the candidate
aggregate table must have a column called "fact_count" (ignoring
case) and this column's type must be numeric.
The following examples would match as "fact count" columns.
</p>
<blockquote>
    <code>fact_count<br>
    FACT_COUNT<br>
    fact_COUNT</code><br>
</blockquote>
<p>
Following matching the "fact count" column, the candidate aggregate
table's columns are examined for possible foreign key matches.
For each of the foreign key column names in the fact table it
is determined if there are any character case independent matches
of the aggregate table's columns. Those columns that match are
noted. It is alright if no columns match; the aggregate might
be a "collapsed" dimension aggregate with no fact table foreign
keys remaining.
If the fact table had foreign key columns "store_id" and "time_id",
then the following aggregate table columns (for example) would match:
</p>
<ul>
	<li><code>time_id</code></li>
	<li><code>store_id</code></li>
	<li><code>TIME_ID</code></li>
	<li><code>STORE_ID</code></li>
	<li><code>time_ID</code></li>
	<li><code>STORE_id</code><Br></li>
</ul>
<p>
At this point, matches are looked for the level and measure columns.
Both of these matching rules are multi-part - has sub rules; 
each rule has more than
one possible regular expression that might match where a match on any
one is a match.
</p>
<p>
There are three sub rules for matching level columns. Each is a template
which is parameterized with 1) the fact table's cube's dimension
hierarchy's name, "hierarchy_name", 2) the fact table's cube's dimension
hierarchy's level name, "level_name", and 3) the dimension table's level 
column name, "level_column_name":
</p>
<ul>
	<li><code>${hierarchy_name}_${level_name}</code></li>
	<li><code>${hierarchy_name}_${level_column_name}</code></li>
	<li><code>${level_column_name}</code><br></li>
</ul>
<p>
If any of these parameters have space characters, ' ', these are
mapped to underscore characters, '_', and, similarly, dot characters,
'.', are also mapped to underscores.
So, if the hierarchy_name is "Time", level_name is "Month" and 
level_column_name is month_of_year, the possible aggregate table column 
names are:
</p>
<ul>
	<li><code>time_month</code></li>
	<li><code>time_month_of_year</code></li>
	<li><code>month_of_year</code><br></li>
</ul>
<p>
For this rule, the "hierarchy_name" and "level_name" are converted to
lower case while the "level_column_name" must match exactly.
</p>
<p>
Lastly, there is the rule for measures. There are three parameters
to matching aggregate columns to measures: 1) the fact table's
cube's measure name, "measure_name", 2) the fact table's cube's measure
column name, "measure_column_name", and 3) the fact table's cube's measure's
aggregator (sum, avg, max, etc.), "aggregate_name".
</p>
<ul>
	<li><code>${measure_name}</code></li>
	<li><code>${measure_column_name}</code></li>
	<li><code>${measure_column_name}_${aggregate_name}</code><br></li>
</ul>
<p>
where the measure name is converted to lower case and both the measure
column name and aggregate name are matched as they appear.
If the fact table's cube's measure name was, "Avg Unit Sales", 
the fact table's measure 
column name
is "unit_sales", and, lastly, the fact table's cube's measure's 
aggregate name is "avg", then possible aggregate table column names 
that would match are:
</p>
<ul>
	<li><code>avg_unit_sales</code></li>
	<li><code>unit_sales</code></li>
	<li><code>unit_sales_avg</code><br></li>
</ul>
<!--
<blockquote>
<pre>
aggregate table name
        template rule: 
            agg_.+_${fact_table_name}
                ignore case of parameter (default)
        example:
            parameter fact_table_name == sales_fact_1997
            regular expression becomes:
                agg_.+_sales_fact_1997
            matches:
                agg_l_05_sales_fact_1997
                agg_c_14_sales_fact_1997
                agg_lc_100_sales_fact_1997
                agg_c_special_sales_fact_1997

fact_count column
        template rule: 
            fact_count (not parameterized)
                ignore case (default)
        example:
            no parameter
            regular expression becomes:
                fact_count
            matches:
                fact_count
                FACT_COUNT
                FaCt_coUNT

foreign key column
        template rule: 
            ${foreign_key}
                ignore case of parameter (default)
        example:
            parameter foreign_key == time_id
            regular expression becomes: 
                time_id
            matches:
                time_id
                TIME_ID

level column
        template rule: 
            ${hierarchy_name}_${level_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${hierarchy_name}_${level_column_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${level_column_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
        example:
            parameter hierarchy_name == Time
            parameter level_name == Month
            parameter level_column_name == month_of_year
            regular expression becomes:
                time_month
                time_month_of_year
                month_of_year
            matches:
                time_month
                time_month_of_year
                month_of_year

measure column
        template rule: 
            ${measure_name}
                lower case
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${measure_column_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
            ${measure_column_name}_${aggregate_name}
                exact case match
                ' ' maps to '_' (default)
                '.' maps to '_' (default)
        example:
            parameter measure_name == Avg Unit Sales
            parameter measure_column_name == unit_sales
            parameter aggregate_name == avg
            regular expression becomes:
                avg_unit_sales
                unit_sales
                unit_sales_avg
            matches:
                avg_unit_sales
                unit_sales
                unit_sales_avg
</pre>
</blockquote>
-->
<p>
For Mondrian developers there are 
<a href="developer_notes.html">additional notes</a>
describing the default rule recognition schema.
</p>
<h3><a name="Recognizing_explicit">Explicit aggregates</a></h3>
<p>
On a per cube basis, in a schema file a user can both include and
exclude aggregate tables. A table that would have been include as
an aggregate by the default rules can be explicitly excluded. A
table that would not be include by the default rules can be
explicitly included. A table that would have only been partially
recognized by the default rules and, therefore, resulted in a
warning or error message, can be explicitly include in rules
specified in the cube's definition.
</p>
<p>
Below is an example for the FoodMart
<code>
Sales
</code>
cube
with fact table
<code>
sales_fact_1997</code>. There are child elements of the 
<code>
Table
</code>
element that deal with aggregate table recognition.
</p>
<blockquote>
<pre>
&lt;Cube name="Sales"&gt;
  &lt;Table name="sales_fact_1997"&gt;
    &lt;AggExclude name="agg_c_14_sales_fact_1997" /&gt;
    &lt;AggExclude name="agg_lc_10_sales_fact_1997" /&gt;
    &lt;AggExclude name="agg_pc_10_sales_fact_1997" /&gt;
    &lt;AggName name="agg_c_special_sales_fact_1997"&gt;
        &lt;AggFactCount column="FACT_COUNT"/&gt;
        &lt;AggIgnoreColumn column="admin_one"/&gt;
        &lt;AggIgnoreColumn column="admin_two"/&gt;
        &lt;AggForeignKey factColumn="product_id" aggColumn="PRODUCT_ID" /&gt;
        &lt;AggForeignKey factColumn="customer_id" aggColumn="CUSTOMER_ID" /&gt;
        &lt;AggForeignKey factColumn="promotion_id" aggColumn="PROMOTION_ID" /&gt;
        &lt;AggForeignKey factColumn="store_id" aggColumn="STORE_ID" /&gt;
        &lt;AggMeasure name="[Measures].[Unit Sales]" column="UNIT_SALES_SUM" /&gt;
        &lt;AggMeasure name="[Measures].[Store Cost]" column="STORE_COST_SUM" /&gt;
        &lt;AggMeasure name="[Measures].[Store Sales]" column="STORE_SALES_SUM" /&gt;
        &lt;AggLevel name="[Time].[Year]" column="TIME_YEAR" /&gt;
        &lt;AggLevel name="[Time].[Quarter]" column="TIME_QUARTER" /&gt;
        &lt;AggLevel name="[Time].[Month]" column="TIME_MONTH" /&gt;
    &lt;/AggName&gt;
    &lt;AggPattern name="agg_sales_fact_1997_.*"&gt;
      ....
      &lt;AggExclude name="agg_sales_fact_1997_olddata" /&gt;
      &lt;AggExclude pattern="agg_sales_fact_1997_test.*" /&gt;
    &lt;/AggPattern&gt;
  
  &lt;/Table&gt;
....
&lt;/Cube&gt;
</pre>
</blockquote>
<p>
The
<code>
AggExclude
</code>
elements define tables that should not be considered aggregates of the
fact table. In this case Mondrian is instructed to ignore the tables
<code>
agg_c_14_sales_fact_1997,
agg_lc_10_sales_fact_1997
</code>
and
<code>
agg_pc_10_sales_fact_1997.
</code>
Following the excludes is the 
<code>
AggName
</code>
element which identifies the name of an aggregate table
table,
<code>
agg_c_special_sales_fact_1997,
</code>
and rules for mapping names from the fact table and cube to it.
The two
<code>
AggIgnoreColumn
</code>
elements are used to specifically state to Mondrian that the columns
<code>
admin_one
</code>
and
<code>
admin_two
</code>
are known and should be ignored. If these columns were not so
identified, Mondrian at the end of determining the fitness of 
the 
<code>
agg_c_special_sales_fact_1997
</code>
table to be an aggregate  of the 
<code>
sales_fact_1997
</code>
fact table would complain that there were extra unidentified columns
and that the mapping was incomplete.
The
<code>
AggForeignKey
</code>
elements define mappings from the 
<code>
sales_fact_1997
</code>
fact table foreign key column 
names into the
<code>
agg_c_special_sales_fact_1997
</code>
aggregate table column names.
</p>
<p>
Both the
<code>
AggMeasure
</code>
and
<code>
AggLevel
</code>
elements map "logical" name, names defined in the cube's schema,
to the aggregate table's column names.
An aggregate table does not have to have all of the measures
that are found in the base fact table, so it is not a requirement
that all of the fact table measures appear as 
<code>
AggMeasure
</code>
mappings, though it will certainly be the most common case.
The most notable exception are 
<code>
distinct count
</code>
measures; such a measure can be aggregated, but one can not
aggregate further on the measure - the "distinctness" of the
measure has been lost during the first aggregation.
</p>
<p>
The
<code>
AggLevel
</code>
entries correspond to collapsed dimensions. For each collapsed
dimension there is a hierarchy of levels spanning from the top
level down to some intermediate level (with no gaps).
</p>
<p>
The 
<code>
AggName
</code>
element is followed by an
<code>
AggPattern
</code>
element.
This matches candidate aggregate table names using a 
regular expression. Included as child elements of the
<code>
AggPattern
</code>
element are two
<code>
AggExclude
</code>
elements. These specifically state what table names should not
be considered by this
<code>
AggPattern
</code>
element.
</p>
<p>
In a given
<code> 
Table
</code>
element, all of the 
<code>
AggExclude
</code>
are applied first, followed by the
<code>
AggName
</code>
element rules and then the
<code>
AggPattern
</code>
rules.
In the case where the same fact table is used by multiple cubes,
the above still applies, but its across all of the aggregation
rules in all of the multiple cube's
<code> 
Table
</code>
elements.
The first "Agg" element,
name or pattern, that matches per candidate aggregate table
name has its associated rules applied.
</p>

<p>
Most of the time, the scope of these
include/exclude statements apply only to the cube in question, but
not always. A cube has a fact table and it is the characteristics
of the fact table (like column names) against
which some of the aggregate table rules are applied. But, a fact table
can actually be the basis of more than one cube. In the FoodMart
schema the 
<code>
sales_fact_1997
</code>
fact table applies to both the 
<code>
Sales
</code>
and the
<code>
Sales Ragged
</code>
cubes.
What this means is that any explicit rules defined in the 
<code>
Sales
</code>
cube also applies to the 
<code>
Sales Ragged
</code>
cube and visa versa.
</p>
<p>
One feature of the explicit recognizer is very useful. With a single
line in the cubes definition in the schema file, 
one can force Mondrian not to recognize any aggregate tables
for the cube's fact table. As an example, for the FoodMart Sales cube
the following excludes all aggregate tables because the regular expression 
pattern
<code>
".*"
</code>
matches all candidate aggregate table names.
</p>
<blockquote>
<pre>
&lt;Table name="sales_fact_1997" &gt;
&nbsp; &nbsp; &lt;AggExclude pattern=".*" /&gt;
&lt;/Table&gt;
</pre>
</blockquote>
<p>
During aggregate table recognition, 
rather than fail silently, Mondrian is rather noisy about things
it can not figure out.
</p>

<h2>
<a name="How_Mondrian_uses_aggregate_tables">How Mondrian uses aggregate tables</a></h2>

<p>
In general Mondrian looks for the nearest hit. If there is no aggregate table at 
the desired granularity, Mondrian rolls up from an aggregate table of lower 
granularity. See property <code>mondrian.rolap.aggregates.ChooseByVolume</code>.</p>

<h3>
Distinct count</h3>

<p>
There is an important exception for distinct-count measures: they cannot be 
rolled up. To see why, consider the case of a supermarket chain which has two 
stores in the same city. Suppose that Store A has 1000 visits from 800 distinct 
customers in the month of July, while Store B has 1500 visits from 900 distinct 
customers. Clearly the two stores had a total of 2500 customer visits between 
them, but how many distinct customers? We can say that there were at least 900, 
and maybe as many as 1700, but assuming that some customers visit both stores, 
and the real total will be somewhere in between. &quot;Distinct customers&quot; is an 
example of a distinct-count measure, and cannot be deduced by rolling up 
subtotals. You have to go back to the raw data in the fact table.</p>

<p>
So, when evaluating a distinct-count measure, Mondrian can only use aggregate 
table if it has exactly the same granularity as the cell being requested. If 
there is no aggregate table of the desired granularity, Mondrian does NOT use 
the aggregate table, and goes instead against the fact table. Once in memory, 
distinct count measures are cached like other measures, and can be used for 
future queries.</p>

<p>
This has implications for aggregate design. If your application makes extensive 
use of distinct-count measures, you will need to create an aggregate table for 
each granularity where it is used. That could be a lot of aggregate tables! (We 
hope to have a better solution for this problem in future releases.)</p>

<h2>
<a name="Tools_for_designing_and_maintaining_aggregate_tables">Tools for 
designing and maintaining aggregate tables</a></h2>

<p>
Aggregate tables are difficult design and maintain. We make no bones about it. 
But this is the first release in which aggregate tables have been available, and 
we decided to get the internals right rather than building a toolset to make 
them easy to use.</p>

<p>
Unless your dataset is very large, Mondrian's performance will be just fine 
without aggregate tables. If Mondrian isn't performing well, you should first 
check that your DBMS is well-tuned: see our guide to
<a href="optimizing_performance.html">optimizing performance</a>). If decide to 
build aggregate tables anyway, we don't offer any tools to help administrators 
design them, so unless you are blessed with superhuman patience and intuition, 
using them won't be smooth sailing.
</p>

<p>
Here are some ideas for tools we'd like to build in the future. I'm thinking of these being utilities, not part of the core runtime engine.
There's plenty of room to wrap these utilities in nice graphical interfaces,
make them smarter.</p>

<h3>
<a name="AggGen_aggregate_generator">AggGen (aggregate generator)</a></h3>

<p>
<code>AggGen</code> is a tool that generates SQL to support the
creation and maintenance of aggregate tables, and would give a
template for the creation of materialized views for databases that
support those. Given an MDX query, the generated create/insert SQL is
optimal for the given query. The generated SQL covers both the "lost"
and "collapsed" dimensions. For usage, see the documentation for
<a href="cmdrunner.html#AggGen">CmdRunner</a>.</p>

<h3>
<a name="Aggregate_table_populater">Aggregate table populater</a></h3>

<p>This utility populates (or generates INSERT statements to populate) the agg
tables.<p>For extra credit: populate the tables in topological order, so that 
higher level aggregations can be built from lower level aggregations.<h3>
<a name="Script_generator">Script 
generator</a></h3>

<p>This utility generates a script containing CREATE TABLE and CREATE INDEX
statements all possible aggregate tables (including indexes), XML for these
tables, and comments indicating the estimated number of rows in these
tables. Clearly this will be a huge script, and it would be ridiculous to
create all of these tables. The person designing the schema could copy/paste
from this file to create their own schema.

<h3><a name="Recommender">Recommender</a></h3>

<p>This utility (maybe graphical, maybe text-based) recommends a set of
aggregate tables. This is essentially an optimization algorithm, and it is
described in the academic literature [<a href="#Ref_AAD96">AAD<sup>+</sup>96</a>]. Constraints on the optimization
process are the amount of storage required, the estimated time to populate
the agg tables.<p>The algorithm could also take into account usage
information. A set of sample queries could be an input to the utility, or the 
utility could run as a background task, consuming the query log and dynamically 
making recommendations.<h3><a name="Online_offline_control">Online/offline control</a></h3>

<p>This utility would allow agg tables to be taken offline/online while Mondrian is still
running.

<h2><a name="Aggregate_properties">Properties which affect aggregates</a></h2>
<p>
Mondrian has properties that control the behavior of its aggregate
table sub-system.
</p>
<p>
</p>

<blockquote>
<table border="1" style="border-width: 0">
  <tbody>
    <tr>
      <th>Property</th>
      <th>Type</th>
      <th>Default Value</th>
      <th>Description</th>
    </tr>

    <tr>
      <td><code>
		<a href="api/mondrian/olap/MondrianProperties.html#UseAggregates">mondrian.rolap.aggregates.Use</a></code></td>
      <td><code>boolean</code></td>
      <td><code>false</code></td>
      <td>
        If set to true, then Mondrian uses any aggregate tables that have
        been read.
        These tables are then candidates
        for use in fulfilling MDX queries.
        If set to false, then no aggregate table related activity 
        takes place in Mondrian.
      </td>
    </tr>

    <tr>
      <td><code>
		<a href="api/mondrian/olap/MondrianProperties.html#ReadAggregates">mondrian.rolap.aggregates.Read</a></code></td>
      <td><code>boolean</code></td>
      <td><code>false</code></td>
      <td>
        If set to true, then Mondrian reads the database schema and
        recognizes aggregate tables. These tables are then candidates
        for use in fulfilling MDX queries.
        If set to false, then aggregate table will not be read from 
        the database. Of course, after aggregate tables have been read,
        they are read, so setting this property false after starting
        with the property being true, has no effect.
        Mondrian will not actually use the aggregate tables unless the
        <code>mondrian.rolap.aggregates.Use</code> property is set to true.
      </td>
    </tr>

    <tr>
      <td><code>
		<a href="api/mondrian/olap/MondrianProperties.html#ChooseAggregateByVolume">mondrian.rolap.aggregates.ChooseByVolume</a></code></td>
      <td><code>boolean</code></td>
      <td><code>false</code></td>
      <td>
        Currently, Mondrian support to algorithms for selecting which
        aggregate table to use: the aggregate with smallest row count
        or the aggregate with smallest volume (row count * row size).
        If set to false, then row count is used. If true, then volume
        is used.
      </td>
    </tr>
    <tr>
      <td><code>
		<a href="api/mondrian/olap/MondrianProperties.html#AggregateRules">mondrian.rolap.aggregates.rules</a></code></td>
      <td><code>resource or url</code></td>
      <td><code>/DefaultRules.xml</code></td>
      <td>
        This is a developer property, not a user property.
        Setting this to a url (e.g., <code>file://c:/myrules.xml</code>) allows one
        to use their own "default" Mondrian aggregate table recognition
        rules. 
        In general use this should never be changed from the default value.
      </td>
    </tr>
    <tr>
      <td><code>
		<a href="api/mondrian/olap/MondrianProperties.html#AggregateRuleTag">mondrian.rolap.aggregates.rule.tag</a></code></td>
      <td><code>string</code></td>
      <td><code>default</code></td>
      <td>
        This is also a developer property. It allows one to pick which 
        named rule in the default rule file to use.
        In general use this should never be changed from the default value.
      </td>
    </tr>
  </tbody>
</table>
</blockquote>


<h2><a name="References">References</a></h2>
<table border="0" id="table1" cellpadding="4">
	<tr>
		<td>[GBLP96]</td>
		<td>J. Gray, A. Bosworth, A. Layman, and H. Pirahesh. Data cube: A 
		relational aggregation operator generalizing group-by, cross-tab, and 
		sub-totals. In Proc. 12th ICDE, pages 152-159, New Orleans, March 1996. 
		[<a target="_blank" href="ftp://ftp.research.microsoft.com/pub/tr/tr-97-32.pdf">pdf</a>]</td>
	</tr>
	<tr>
		<td>[<a name="Ref_AAD96">AAD<sup>+</sup>96</a>]</td>
		<td>S. Agarwal, R. Agrawal, P. M. Deshpande, A. Gupta, J. F. Naughton, 
		R. Ramakrishnan, and S. Sarawagi. On the computation of multidimensional 
		aggregates. In Proc. 22nd VLDB, pages 506-521, Mumbai, Sept. 1996. [<a href="http://www.almaden.ibm.com/software/quest/Publications/papers/vldb96_cube.pdf">pdf</a>]</td>
	</tr>
	<tr>
		<td>[ABDGHLS99]</td>
		<td>J. Albrecht, A. Bauer, O. Deyerling, H. Gunze, W. Hummer, W. Lehner, 
		L. Schlesinger. Management of Multidimensional Aggregates for Efficient 
		Online Analytical Processing, Proceedings of International Database 
		Engineering and Applications Symposium, 1999, pp. 156 164. [<a href="http://www6.informatik.uni-erlangen.de/research/projects/cubestar/english/Overview.html">pdf</a>]</td>
	</tr>
	<tr>
		<td>[Rittman05]</td>
		<td>M. Rittman. Compressed Composites (Oracle 10g Compression) 
		Explained. Online article. [<a href="http://www.rittman.net/archives/001173.html">html</a>]</td>
	</tr>
</table>

<hr>

<table border="0" class="clsStd" width="100%" style="border-collapse: collapse" bordercolor="#111111" cellpadding="0" cellspacing="0">
  <tr>
    <td class="content">
      <a target="_top" href="index.html">Home</a> |
      <a target="_top" href="noframes.html">No frames</a> | This file is<i>
      <a href="http://mondrian.sourceforge.net/aggregate_tables.html">
        $Id$
      </a></i> (<a href="http://perforce.eigenbase.org:8080/open/mondrian/doc/aggregate_tables.html?ac=22">log</a>)</td>
    <td align="right">
      <a href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=35302&type=1" width="88" height="31" border="0" alt="SourceForge.net Logo">
      </a>
    </td>
  </tr>
</table>

</body>

</html>
