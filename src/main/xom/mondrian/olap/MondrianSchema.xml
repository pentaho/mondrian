<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="../../../../misc/Meta.xsl" ?>
<!--
  == $Id$
  == This software is subject to the terms of the Eclipse Public License v1.0
  == Agreement, available at the following URL:
  == http://www.eclipse.org/legal/epl-v10.html.
  == You must accept the terms of that agreement to use this software.
  ==
  == Copyright (C) 2001-2005 Julian Hyde
  == Copyright (C) 2005-2013 Pentaho and others
  == All Rights Reserved.
  ==
  == Defines an XML model for a Mondrian schema.

Measure group versus RolapStar.

Cube [logical]
==============
 * consists of multiple measure groups

Measure group [logical]
=======================
Contains:
  * Measures (map to PhysColumn)
  * Mapping to RolapDimension (yields a PhysPath)

RolapStar [between logical and physical]
========================================
 * Set of columns
 * Each column has a bit position (contiguous and unique within the star)
 * Each column has a path to the fact table
 * Tables and columns are not related to physTable and physColumn

AggStar [same level as RolapStar]
=================================
 * Should probably be a subclass of RolapStar, with more information on
   tables, columns, but currently is not

Aggregate tables are very similar to fact tables of different granularities.
The main difference is that an aggregate table does not DEFINE a measure; it
just provides a usage of it. Questions:

1. Do agg tables BELONG TO a measure group? Is it possible to have an agg
   table (at a high level of aggregation) that contains measures of more than
   one measure group? Answer: Yes, it seems to make sense. But it would be
   difficult to define these in the schema, and probably wouldn't be used much
   in practice.

2. Should we continue to represent agg tables using something at the same
   level as RolapStar?

PhysColumn, PhysTable [physical]
================================
 * table may be real, inline, derived
 * column may be derived
 * relationships between tables are used only when a dimension has more than
   one table (links between dimension and measure group are determined by
   attribute linkages - a different mechanism)
 * may be used by several dimensions and measure groups in same schema

Cell request
============

Currently has a set of RolapStar.Column that constrain it, and a value for each.

Could be a set of (RolapAttribute, {KEY|NAME|propName}, PhysPath}.
Yuck - mixes levels, and {KEY|NAME|propName} does not scale.

What if RolapStar.Column contains (PhysColumn, PhysPath)?

When you constrain a particular level against a particular measureGroup,
you iterate over the key columns (each a PhysColumn) of the level's attribute,
find the full path from the fact table (first from the measureGroup's
fact table to the dimension's key, then from the dimension's key to each key
column. Then you lookup a RolapStar.Column with that path.

Mappings:
(measureGroup, dimension) -> (physPath)        # path to attach dim to mGroup
level -> attribute                             # level based on attr
attribute -> set of {physColumn}               # key cols of attribute
(key: physColumn, root: physCol) -> physPath   # connect key to root of dim

Redundant short-cut mapping:
(physColumn, dimension, measureGroup)
  -> (ordinal, physColumn, physPath)

(Given a column, the key of a level's attribute, the dimension it belongs to,
and the measureGroup it is joining to, the RolapStar.Column gives the path
from that column to the RolapStar's fact table.

A given RolapStar has a fact table (a physTable) and all paths end there.

It is possible for a PhysColumn to occur more than once within the same
RolapStar, provided that it has different paths. That means that it has
come from different dimensions, because if a physColumn is used multiple
times in the same dimension, it will always have the same path.

In other words, (physColumn, physPath) uniquely identifies a RolapStar.Column.


  -->
<Model
 name="mondrian"
 dtdName="mondrian.dtd"
 className="MondrianDef"
 packageName="mondrian.olap"
 importName="mondrian.rolap.sql.SqlQuery; import mondrian.util.Pair; import java.util.*; import org.olap4j.metadata.NamedList; import org.eigenbase.xom.ElementDef; import org.eigenbase.xom.NodeDef"
 root="Schema"
 defaultKeepDef="true"
 version="1.0">
    <Doc>
<p>XML model for Mondrian schemas. It is generated from
<code>MondrianSchema.xml</code>.</p>

<p>See also {@link Mondrian3Def} (generated from
<code>Mondrian3Schema.xml</code>), which is the XML model for Mondrian
version 3.x schemas.</p>
    </Doc>

    <Class class="CubeElement">
        <Doc>
            Child element of a Cube.
        </Doc>
    </Class>

    <Class class="LevelElement">
        <Doc>
            Child element of a Level.
        </Doc>
    </Class>

    <Class class="MeasureElement">
        <Doc>
            Child element of a Measure.
        </Doc>
    </Class>

    <Class class="CalculatedMemberElement">
        <Doc>
            Child element of a CalculatedMember.
        </Doc>
    </Class>

    <Class class="NamedSetElement">
        <Doc>
            Child element of a NamedSet.
        </Doc>
    </Class>

    <Class class="DimensionElement">
        <Doc>
            Child element of a Dimension.
        </Doc>
    </Class>

    <Class class="PropertyElement">
        <Doc>
            Child element of a Property.
        </Doc>
    </Class>

    <Class class="NamedElement">
        <Code><![CDATA[
        String getNameAttribute();
        /**
         * {@inheritDoc}
         *
         * <p>Override NodeDef; any code calling this method should consider
         * calling {@link #getNameAttribute} instead.</p>
         */
        String getName();
        ]]></Code>
    </Class>

    <Class class="SchemaElement">
        <Doc>Child element of a Schema.</Doc>
    </Class>

    <Class class="MeasureGroupElement">
        <Doc>Child element of a MeasureGroup.</Doc>
    </Class>

    <Class class="TableElement">
        <Doc>Child element of a Table.</Doc>
    </Class>

    <Class class="InlineTableElement">
        <Doc>Child element of an InlineTable.</Doc>
    </Class>

    <Class class="RoleElement">
        <Doc>
            Child element of a Role.
        </Doc>
    </Class>

    <Class class="Holder">
        <Doc>Element that contains children.</Doc>
        <Code>
            <![CDATA[
                List<? extends NodeDef> list();
                Holder copy();
            ]]>
        </Code>
    </Class>

    <!-- Schema ========================================================== -->
    <Element type="Schema" class="NamedElement">
        <Doc>
            <p>A schema is a collection of cubes.
            It can also contain shared dimensions (for use by those
            cubes), named sets, roles, and declarations of
            user-defined functions.</p>
        </Doc>
        <Attribute name="name" required="true">
            <Doc>Name of this schema.</Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the Schema's name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this Schema.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="measuresCaption" required="false">
            <Doc>
                Label for the measures dimension.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="defaultRole" required="false">
            <Doc>The name of the default role for connections to this schema</Doc>
        </Attribute>
        <Attribute name="quoteSql" required="false" type="Boolean" default="true">
            <Doc>Whether to quote identifiers (table and column names) when
                generating SQL. The default is true.

                <p>Identifiers that are not alphanumeric are always quoted.</p>

                <p>If this property is false, identifiers are not quoted. Most
                    databases' SQL parsers convert quoted identifiers to upper
                    case. Thus
                    <blockquote>SELECT ename FROM emp</blockquote>
                    is equivalent to
                    <blockquote>SELECT `ENAME` FROM `EMP`</blockquote>
                    and
                    <blockquote>SELECT ENAME FROM EMP</blockquote>. Therefore
                    you should typically set <code>quoteSql</code> to
                    <code>false</code> if and only if you used unquoted DDL
                    to create your database.</p>
            </Doc>
        </Attribute>
        <Attribute name="missingLink" required="true" default="warning">
            <Doc>
                Action if there is no link in a measure group for each
                dimension in a cube. Valid values are 'ignore', 'warning' (the
                default) and 'error'. Use the 'NoLink' element to prevent
                warnings/errors by explicitly declaring that a dimension is not
                linked.
            </Doc>
            <Value>ignore</Value>
            <Value>warning</Value>
            <Value>error</Value>
        </Attribute>
        <Attribute name="metamodelVersion" required="false">
            <Doc>
                <p>Version of the Mondrian XML metamodel that created this
                    schema. Typically this is the same as the Mondrian version
                    number (e.g. "4.0.0" or "3.3").</p>

                <p>There was a major change in format with Mondrian version 4.
                    Not coincidentally, this attribute was introduced at that
                    time. Mondrian can detect that a schema is in the earlier
                    format, and attempt to upgrade it. The attribute is not
                    necessary for this detection, but it makes the process
                    more efficient: Mondrian only needs to parse the file
                    once.</p>
            </Doc>
        </Attribute>
        <Attribute name="locales" required="false">
            <Doc>
                <p>Comma-separated list of locales for which this schema is
                localized. For example, 'en,en-GB,fr'.</p>

                <p>This list tells the server which locales to attempt to
                load.</p>

                <p>It is legal to call {@link Connection#setLocale} with
                any locale. If you supply a locale not supported by the server,
                the server will not complain, but use the nearest. For
                example, if you specify 'fr-CA' it will use 'fr'.</p>
            </Doc>
        </Attribute>
        <Array name="childArray" type="SchemaElement">
            <Doc>
                Child elements of this Schema. PhysicalSchema (at most once),
                Dimension, Cube, Role, NamedSet, UserDefinedFunction, Parameter,
                Annotations (at most once), in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() { return name; }
            private static final SchemaElement[] EMPTY = {};
            public final Children<SchemaElement> children =
                new Children<SchemaElement>(
                    SchemaElement.class,
                    Cube.class,
                    Dimension.class,
                    Role.class,
                    NamedSet.class,
                    UserDefinedFunction.class,
                    Parameter.class,
                    PhysicalSchema.class,
                    Annotations.class)
                {
                    SchemaElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(SchemaElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<Cube> getCubes() {
                return children.filterNamed(Cube.class);
            }
            public NamedList<Dimension> getDimensions() {
                return children.filterNamed(Dimension.class);
            }
            public NamedList<Role> getRoles() {
                return children.filterNamed(Role.class);
            }
            public NamedList<NamedSet> getNamedSets() {
                return children.filterNamed(NamedSet.class);
            }
            public NamedList<UserDefinedFunction> getUserDefinedFunctions() {
                return children.filterNamed(UserDefinedFunction.class);
            }
            public NamedList<Parameter> getParameters() {
                return children.filterNamed(Parameter.class);
            }
            public PhysicalSchema getPhysicalSchema() {
                return children.singleton(PhysicalSchema.class);
            }
            public Localization getLocalization() {
                return children.singleton(Localization.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
        }

        // Some static methods.
        //
        // To generate this block, we fool XOM's code generation using the
        // 'injection' kludge of a close brace (above) and open brace (below).

        private static String first(String s0, String s1) {
            if (s0 != null) {
                return s0;
            }
            return s1;
        }

        private static <T> T only(Object[] os, Class<T> clazz) {
            T t = null;
            for (Object o : os) {
                if (clazz.isInstance(o)) {
                    if (t != null) {
                        Handler.THREAD_LOCAL.get().error(
                            "More than one " + clazz.getSimpleName()
                            + " element found; ignoring all but first",
                            (NodeDef) o,
                            null);
                    }
                    t = clazz.cast(o);
                }
            }
            return t;
        }

        private static <T extends Holder> T onlyDeflt(Object[] os, Class<T> clazz, T dflt) {
            T t = null;
            for (Object o : os) {
                if (clazz.isInstance(o)) {
                    if (t != null) {
                        Handler.THREAD_LOCAL.get().error(
                            "More than one " + clazz.getSimpleName()
                                + " element found; ignoring all but first",
                            (NodeDef) o,
                            null);
                    }
                    t = clazz.cast(o);
                }
            }
            return t == null ? (T) dflt.copy() : t;
        }

        private static <T> List<T> list(Object[] os, Class<T> clazz) {
            if (os == null) {
                return Collections.emptyList();
            }
            final List<T> list = new ArrayList<T>();
            for (Object o : os) {
                if (clazz.isInstance(o)) {
                    list.add(clazz.cast(o));
                }
            }
            return list;
        }

        private static <T extends NamedElement> NamedList<T> namedList(Object[] os, Class<T> clazz) {
            if (os == null) {
                return org.olap4j.impl.Olap4jUtil.emptyNamedList();
            }
            return new NamedListImpl<T>(list(os, clazz));
        }

        private static <T> List<T> list(T[] ts) {
            return Arrays.asList(ts);
        }

        private static <T extends NamedElement> NamedList<T> namedList(T[] ts) {
            if (ts.length == 0) {
                return org.olap4j.impl.Olap4jUtil.emptyNamedList();
            }
            return new NamedListImpl<T>(list(ts));
        }

        public static abstract class Children<T extends NodeDef> implements Iterable<T> {
            private final Class[] classes;

            Children(Class<T> iface, Class<? extends T>... classes) {
                for (Class clazz : classes) {
                    if (!iface.isAssignableFrom(clazz)) {
                        System.out.println(clazz + " should be a " + iface);
                    }
                }
                this.classes = classes;
            }

            abstract T[] getArray();

            abstract void setArray(T[] t);

            public Iterator<T> iterator() {
                return list(getArray()).iterator();
            }

            <T2> List<T2> filter(Class<T2> clazz) {
                return list(getArray(), clazz);
            }

            <T2 extends NamedElement> NamedList<T2> filterNamed(Class<T2> clazz) {
                return namedList(getArray(), clazz);
            }

            <T2> T2 singleton(Class<T2> clazz) {
                return MondrianDef.only(getArray(), clazz);
            }

            <T2> T2 requiredSingleton(ElementDef xml, Class<T2> clazz) throws Missing {
                T2 t2 = MondrianDef.only(getArray(), clazz);
                if (t2 != null) {
                    return t2;
                }
                Handler.THREAD_LOCAL.get().error(
                    "Missing required child element " + clazz.getSimpleName(),
                    xml,
                    null);
                throw Missing.INSTANCE;
            }

            <T2 extends Holder> T2 only(T2 empty) {
                return MondrianDef.onlyDeflt(getArray(), (Class<T2>) empty.getClass(), empty);
            }

            public void add(T t) {
                T[] ts = getArray();
                T[] t2s = Util.copyOf(ts, ts.length + 1);
                t2s[t2s.length - 1] = t;
                setArray(t2s);
            }

            public void add(int i, T t) {
                T[] ts = getArray();
                T[] t2s = Util.copyOf(ts, ts.length + 1);
                System.arraycopy(t2s, i, t2s, i + 1, t2s.length - 1 - i);
                t2s[i] = t;
                setArray(t2s);
            }

            public void addAll(Iterable<? extends T> ts) {
                // TODO: tune: just resize array once
                for (T t : ts) {
                    add(t);
                }
            }

            public <T1 extends Holder> T1 holder(T1 holder) {
                for (T t : getArray()) {
                    if (t.getClass() == holder.getClass()) {
                        return (T1) t;
                    }
                }
                add((T) holder);
                return holder;
            }
        }

        /** Thrown to signal that a mandatory element is missing. An error will
          * already have been posted. Client code should handle the exception
          * and carry on. */
        public static class Missing extends Exception {
            private Missing() {
            }
            private static final Missing INSTANCE = new Missing();
        }

        protected static abstract class MutableArrayList<T> extends AbstractList<T> {
            protected abstract T[] getArray();
            protected abstract void setArray(T[] ts);

            public T get(int index) {
                return getArray()[index];
            }

            public int size() {
                return getArray().length;
            }

            public T set(int i, T t) {
                final T[] ts = getArray();
                final T old = ts[i];
                ts[i] = t;
                return old;
            }

            public void add(int i, T t) {
                final T[] ts = getArray();
                T[] t2s = Util.copyOf(ts, ts.length + 1);
                System.arraycopy(t2s, i, t2s, i + 1, t2s.length - 1 - i);
                t2s[i] = t;
                setArray(t2s);
            }
        }

        public static class NamedListImpl<T extends NamedElement>
            extends AbstractList<T>
            implements NamedList<T>
        {
            private final List<T> list;

            public NamedListImpl(List<T> list) {
                this.list = list;
            }

            public T get(int index) {
                return list.get(index);
            }

            public int size() {
                return list.size();
            }

            public T get(String name) {
                for (T t : this) {
                    if (t.getNameAttribute().equals(name)) {
                        return t;
                    }
                }
                return null;
            }

            public int indexOfName(String name) {
                for (int i = 0; i < list.size(); ++i) {
                    T t = list.get(i);
                    if (t.getNameAttribute().equals(name)) {
                        return i;
                    }
                }
                return -1;
            }

            public T set(int index, T element) {
                return list.set(index, element);
            }

            public void add(int index, T element) {
                list.add(index, element);
            }

            public Map<String, T> asMap() {
                return new AbstractMap<String, T>() {
                    public Set<Entry<String, T>> entrySet() {
                        return new AbstractSet<Entry<String, T>>() {
                            public Iterator<Entry<String, T>> iterator() {
                                return new Iterator<Entry<String, T>>() {
                                    private int index = -1;
                                    public boolean hasNext() {
                                        return index < list.size();
                                    }
                                    public Entry<String, T> next() {
                                        ++index;
                                        return new Entry<String, T>() {
                                            public String getKey() {
                                                return list.get(index).getNameAttribute();
                                            }
                                            public T getValue() {
                                                return list.get(index);
                                            }
                                            public T setValue(T value) {
                                                throw new UnsupportedOperationException();
                                            };
                                        };
                                    }
                                    public void remove() {
                                        throw new UnsupportedOperationException();
                                    }
                                };
                            }
                            public int size() {
                                return list.size();
                            }
                        };
                    }
                };
            }

            public String getName(Object arg0) {
                return ((T) arg0).getNameAttribute();
            }
        }

        /**
         * Handler for errors that arise while loading a schema.
         */
        public interface Handler {
            ThreadLocal<Handler> THREAD_LOCAL = new ThreadLocal<Handler>();

            /**
             * Reports a non-fatal error. Schema validation can continue, but
             * the schema will not be viable to run queries. Adds the error to
             * the list of warnings that will be returned after validation.
             *
             * <p>If we are not tolerant of warnings and errors
             * (see {@link mondrian.rolap.RolapConnectionProperties#Ignore}),
             * throws immediately. A thrown exception will typically
             * abort the attempt to create the schema.
             *
             * @param message Message
             * @param node XML element that is the location of this exception
             * @param attributeName Name of XML attribute; null for whole node
             */
            void error(
                String message,
                NodeDef node,
                String attributeName);
        }

        private static class _Dummy {

            ]]>
        </Code>
    </Element>

    <!-- Dimension ======================================================== -->
    <Element type="Dimension" class="NamedElement,SchemaElement">
        <Doc>
            A <code>Dimension</code> is a collection of attributes, some them
            organized into hierarchies.

            <p>Dimensions are either defined at the Schema level, or as part of
            a Cube within a Dimensions element.</p>
        </Doc>
        <Attribute name="name" required="false">
            <Doc>
                Name of this dimension.

                <p>If this dimension is specified in a schema, name must be
                    specified. If this dimension is specified in a cube,
                    name is optional; by default, the name is inherited from
                    the source dimension, but the name can be overridden. This
                    is necessary when more than one cube dimension is created
                    from the same schema dimension.</p>
            </Doc>
        </Attribute>
        <Attribute name="source" required="false">
            <Doc>
                Name of the schema dimension that is the source of this cube
                dimension. Not valid for a schema dimension.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                Whether this dimension is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the Dimension's name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this dimension.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="type" required="false" default="OTHER">
            <Doc>
                <p>The dimension's type is typically "OTHER" (default) or "TIME".
                The full set of values is as specified by the XMLA and olap4j
                specifications. See
                <a href="http://www.olap4j.org/api/org/olap4j/metadata/Dimension.Type.html">the
                    Dimension.Type enum in olap4j</a>.</p>

                <p>A <dfn>TIME</dfn> dimension allows the use of the MDX
                time functions (WTD, YTD, QTD, etc).</p>
            </Doc>
            <Value>ACCOUNTS</Value>
            <Value>BILL_OF_MATERIALS</Value>
            <Value>CHANNEL</Value>
            <Value>CURRENCY</Value>
            <Value>CUSTOMERS</Value>
            <Value>GEOGRAPHY</Value>
            <Value>MEASURE</Value>
            <Value>ORGANIZATION</Value>
            <Value>OTHER</Value>
            <Value>PRODUCTS</Value>
            <Value>PROMOTION</Value>
            <Value>QUANTITATIVE</Value>
            <Value>RATES</Value>
            <Value>SCENARIO</Value>
            <Value>TIME</Value>
            <Value>UNKNOWN</Value>
            <Value>UTILITY</Value>
        </Attribute>
        <Attribute name="table" required="false">
            <Doc>
                Default table for Column objects in this Dimension. May be
                overridden at the Attribute or Column level.
            </Doc>
        </Attribute>
        <Attribute name="key" required="false">
            <Doc>
                Name of the attribute that is the key of this dimension.
                Must be specified, unless this dimension is a use of a schema
                dimension (that is, the 'source' attribute is set).
            </Doc>
        </Attribute>
        <Attribute name="hanger" type="Boolean" required="false" default="false">
            <Doc>
                <p>Whether this is a hanger Dimension.</p>

                <p>A hanger dimension has no table; the only members that can
                exist are calculated. The purpose of a hanger dimension is to
                add options that can be used in formulas. The Scenario dimension
                (the system dimension that is created automatically for any
                cube for which enableScenarios is true) is implemented as a
                hanger dimension. </p>

                <p>A Dimension that is declared hanger cannot have a table, nor
                can any of its Attribute elements. The Attribute elements can
                have no declared columns.</p>
            </Doc>
        </Attribute>
        <Array name="childArray" type="DimensionElement">
            <Doc>
                Child elements of this Dimension: Attributes, Hierarchies,
                Annotations can each occur up to once, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name != null ? name : source;
            }
            private static final DimensionElement[] EMPTY = {};
            public final Children<DimensionElement> children =
                new Children<DimensionElement>(
                    DimensionElement.class,
                    Attributes.class,
                    Hierarchies.class,
                    Annotations.class)
                {
                    DimensionElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(DimensionElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<Attribute> getAttributes() {
                return children.only(Attributes.EMPTY).list();
            }
            public NamedList<Hierarchy> getHierarchies() {
                return children.only(Hierarchies.EMPTY).list();
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="Dimensions" class="Holder,CubeElement">
        <Doc>
            Array of Dimensions.

            Note that shared dimensions are direct children of a Schema element.
            The dimensions of a cube reside in a Dimensions holder element.
        </Doc>
        <Array name="array" type="Dimension"/>
        <Code>
            <![CDATA[
            private static final Dimensions EMPTY;
            static {
                EMPTY = new Dimensions();
                EMPTY.array = new Dimension[0];
            }
            public Dimensions copy() {
                Dimensions c = new Dimensions();
                c.array = array.clone();
                return c;
            }
            public NamedList<Dimension> list() {
                return new NamedListImpl<Dimension>(
                    new MutableArrayList<Dimension>() {
                        protected Dimension[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Dimension[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <!-- Cube ============================================================ -->
    <Element type="Cube" class="NamedElement,SchemaElement">
        <Doc>
            Definition of a cube.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this cube.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                Whether this cube is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the cube's name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this cube.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="defaultMeasure" required="false">
            <Doc>
                The name of the measure that would be taken as the default
                measure of the cube.
            </Doc>
        </Attribute>
        <Attribute name="cache" type="Boolean" default="true">
            <Doc>
                Should the Fact table data for this Cube be cached
                by Mondrian or not. The default action is to cache
                the data.
            </Doc>
        </Attribute>
        <Attribute name="enabled" type="Boolean"
                    required="false" default="true">
            <Doc>
                Whether element is enabled - if true, then the Cube is
                realized otherwise it is ignored.
            </Doc>
        </Attribute>
        <Attribute name="enableScenarios" type="Boolean"
                    required="false" default="false">
            <Doc>
                Whether to enable scenarios in this Cube.
                If true, a Scenario dimension will automatically be added to
                the cube. You can then call Cell.setValue to change the value
                of a cell and see the changes propagate to dependent cells.
            </Doc>
        </Attribute>
        <Array name="childArray" type="CubeElement">
            <Doc>
                Child elements of this Cube. Annotations, MeasureGroups,
                Dimensions, CalculatedMembers, NamedSets can each occur at
                most once, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final CubeElement[] EMPTY = {};
            public final Children<CubeElement> children =
                new Children<CubeElement>(
                    CubeElement.class,
                    Annotations.class,
                    MeasureGroups.class,
                    Dimensions.class,
                    CalculatedMembers.class,
                    NamedSets.class)
                {
                    CubeElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(CubeElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<Dimension> getDimensions() {
                return children.only(Dimensions.EMPTY).list();
            }
            public NamedList<MeasureGroup> getMeasureGroups() {
                return children.only(MeasureGroups.EMPTY).list();
            }
            public NamedList<CalculatedMember> getCalculatedMembers() {
                return children.only(CalculatedMembers.EMPTY).list();
            }
            public NamedList<NamedSet> getNamedSets() {
                return children.only(NamedSets.EMPTY).list();
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="Hierarchies" class="Holder,DimensionElement">
        <Doc>A list of Hierarchy elements.</Doc>
        <Array name="array" type="Hierarchy"/>
        <Code>
            <![CDATA[
            private static final Hierarchies EMPTY;
            static {
                EMPTY = new Hierarchies();
                EMPTY.array = new Hierarchy[0];
            }
            public Hierarchies copy() {
                Hierarchies c = new Hierarchies();
                c.array = array.clone();
                return c;
            }
            public NamedList<Hierarchy> list() {
                return new NamedListImpl<Hierarchy>(
                    new MutableArrayList<Hierarchy>() {
                        protected Hierarchy[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Hierarchy[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="Attributes" class="Holder,DimensionElement">
        <Doc>A list of Attribute elements.</Doc>
        <Array name="array" type="Attribute"/>
        <Code>
            <![CDATA[
            private static final Attributes EMPTY;
            static {
                EMPTY = new Attributes();
                EMPTY.array = new Attribute[0];
            }
            public Attributes copy() {
                Attributes c = new Attributes();
                c.array = array.clone();
                return c;
            }
            public NamedList<Attribute> list() {
                return new NamedListImpl<Attribute>(
                    new MutableArrayList<Attribute>() {
                        protected Attribute[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Attribute[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="Attribute" class="NamedElement">
        <Doc>
            <p>An attribute is a data value.</p>

            <p>If you are familiar with modeling relational database schemas,
                then an attribute is the nearest equivalent in the Mondrian
                schema to a column.</p>

            <p>Every attribute belongs to a dimension. (So, continuing the
                analogy, a dimension is the nearest equivalent of a table.)</p>

            <p>By setting <code>hasHierarchy</code>
                to true, you can automatically create a Hierarchy that has
                a single Level based on this attribute, called an attribute
                hierarchy. An attribute can also be used to build multi-level
                hierarchies, by including it in a Level.</p>
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this Attribute.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                Caption of this Attribute.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this Attribute.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
                   required="false" default="true">
            <Doc>
                Whether this attribute is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Attribute name="levelType" required="false" default="Regular">
            <Doc>
                Whether this is a regular or a time-related level.
                The value makes a difference to time-related functions
                such as YTD (year-to-date).
            </Doc>
            <Value>Regular</Value>
            <Value>TimeYears</Value>
            <Value>TimeHalfYear</Value>
            <Value>TimeHalfYears</Value>
            <Value>TimeQuarters</Value>
            <Value>TimeMonths</Value>
            <Value>TimeWeeks</Value>
            <Value>TimeDays</Value>
            <Value>TimeHours</Value>
            <Value>TimeMinutes</Value>
            <Value>TimeSeconds</Value>
            <Value>TimeUndefined</Value>
        </Attribute>

        <Attribute name="approxRowCount" required="false">
            <Doc>
                The estimated number of values of this attribute.
                Setting this property improves the performance of
                MDSCHEMA_LEVELS, MDSCHEMA_HIERARCHIES and
                MDSCHEMA_DIMENSIONS XMLA requests.
            </Doc>
        </Attribute>
        <Attribute name="table" required="false">
            <Doc>
                Default table for Column objects nested within this Attribute.
            </Doc>
        </Attribute>
        <Attribute name="keyColumn">
            <Doc>
                The name of the column that holds the unique identifier of
                this Attribute. See also the Key sub-element.
            </Doc>
        </Attribute>
        <Attribute name="nameColumn">
            <Doc>
                The name of the column that holds the user identifier of
                this level. See also the Name sub-element. If neither nameColumn
                nor Name are specified, defaults to the key.
            </Doc>
        </Attribute>
        <Attribute name="orderByColumn" required="false">
            <Doc>
                The name of the column used to sort members. See also the
                OrderBy sub-element. If neither orderByColumn nor OrderBy are
                specified, defaults to the name.

                <p>If an attribute is used within a multi-level hierarchy,
                the members of one level are always sorted within the parent
                member of the parent level. It is not necessary to explicitly
                include the parent level's key or order-by key in this
                attribute's order key.</p>
            </Doc>
        </Attribute>
        <Attribute name="captionColumn" required="false">
            <Doc>
                The name of the column that holds the caption for
                members. See also the Caption sub-element. If neither
                captionColumn nor Caption are specified, defaults to the name.
            </Doc>
        </Attribute>
        <Attribute name="datatype" default="String">
            <Doc>
                Datatype of this property:
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="hasHierarchy" type="Boolean" required="false" default="true">
            <Doc>
                Whether this attribute has its own hierarchy. The hierarchy
                has the same name as the attribute, a single level with the
                same name as the attribute. Default is <code>true</code>.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyHasAll" type="Boolean" required="false" default="true">
            <Doc>
                Whether the attribute hierarchy has an 'all' member.
                Ignored if <code>hasHierarchy</code> is <code>false</code>.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyCaption" required="false">
            <Doc>
                Caption of the attribute hierarchy.
                Ignored if <code>hasHierarchy</code> is <code>false</code>.
                If this attribute is not specified,
                the caption is the same as the caption of the attribute.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyAllMemberName" required="false">
            <Doc>
                Name of the 'all' member of the attribute hierarchy.
                Ignored if <code>hasHierarchy</code> is <code>false</code>
                or <code>hierarchyHasAll</code> is <code>false</code>.
                If this attribute is not specified,
                the all member is named 'All <i>attributeName</i>', for
                example, 'All Gender' if the attribute is named 'Gender'.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyAllMemberCaption" required="false">
            <Doc>
                Caption of the 'all' member of the attribute hierarchy.
                Ignored if <code>hasHierarchy</code> is <code>false</code>
                or <code>hierarchyHasAll</code> is <code>false</code>.
                If this attribute is not specified, the all member's caption
                is the same as its name.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyAllLevelName" required="false">
            <Doc>
                Name of the 'all' level of the attribute hierarchy.
                Ignored if <code>hasHierarchy</code> is <code>false</code>
                or <code>hierarchyHasAll</code> is <code>false</code>.
                If this attribute is not specified,
                the all level is named '(All)'.
            </Doc>
        </Attribute>
        <Attribute name="hierarchyDefaultMember">
            <Doc>
                Unique name of the default member of the attribute hierarchy.
                Ignored if <code>hasHierarchy</code> is <code>false</code>.
                If not specified, the default member is the 'all' member,
                if the hierarchy has one, otherwise the first member of the
                first level.
            </Doc>
        </Attribute>
        <Array name="childArray" type="AttributeElement">
            <Doc>
                Child elements. Key, Name, OrderBy, Caption,
                MemberFormatter, Annotations can each occur at most once;
                Property can occur multiple times.
            </Doc>
        </Array>
        <Code><![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final AttributeElement[] EMPTY = {};
            public final Children<AttributeElement> children =
                new Children<AttributeElement>(
                    AttributeElement.class,
                    Key.class,
                    Name.class,
                    OrderBy.class,
                    Caption.class,
                    Property.class,
                    MemberFormatter.class,
                    Annotations.class)
                {
                    AttributeElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(AttributeElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<Property> getProperties() {
                return children.filterNamed(Property.class);
            }
            public Key getKey() {
                return children.singleton(Key.class);
            }
            public Name getName_() {
                return children.singleton(Name.class);
            }
            public OrderBy getOrderBy() {
                return children.singleton(OrderBy.class);
            }
            public Caption getCaption() {
                return children.singleton(Caption.class);
            }
            public MemberFormatter getMemberFormatter() {
                return children.singleton(MemberFormatter.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
        ]]>
        </Code>
    </Element>

    <Class class="AttributeElement">
        <Doc>
            Child element of an Attribute.
        </Doc>
    </Class>

    <Element type="Hierarchy" class="NamedElement">
        <Doc>
            Collection of attributes organized into levels.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of the hierarchy.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                Whether this hierarchy is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Attribute name="hasAll" type="Boolean" required="false">
            <Doc>
                Whether this hierarchy has an 'all' member. Default is true.
            </Doc>
        </Attribute>
        <Attribute name="allMemberName" required="false">
            <Doc>
                Name of the 'all' member. If this attribute is not specified,
                the all member is named 'All <i>hierarchyName</i>', for
                example, 'All Stores' if the hierarchy is named 'Stores'.
            </Doc>
        </Attribute>
        <Attribute name="allMemberCaption" required="false">
            <Doc>
                Caption of the 'all' member.
                If this attribute is not specified, the 'all' member's caption
                is the same as its name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="allLevelName" required="false">
            <Doc>
                Name of the 'all' level. If this attribute is not specified,
                the all level is named '(All)'.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="defaultMember">
            <Doc>
                Unique name of the default member of this hierarchy.
                If not specified, the default member is the 'all' member,
                if the hierarchy has one, otherwise the first member of the
                first level.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string to be displayed in the user interface.
                If not specified, the hierarchy's name is used.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this hierarchy.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Array name="childArray" type="HierarchyElement">
            <Doc>
                Child elements of this Hierarchy. Annotations can occur at most
                once; Level can occur several times, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final HierarchyElement[] EMPTY = {};
            public final Children<HierarchyElement> children =
                new Children<HierarchyElement>(
                    HierarchyElement.class,
                    Level.class,
                    Annotations.class)
                {
                    HierarchyElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(HierarchyElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<Level> getLevels() {
                return children.filterNamed(Level.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Class class="HierarchyElement">
        <Doc>
            Child element of a Hierarchy.
        </Doc>
    </Class>

    <Element type="Level" class="NamedElement,HierarchyElement">
        <Attribute name="name" required="false">
            <Doc>
                Name of this Level. If not specified, defaults to the name of
                the source attribute.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean"
            required="false" default="true">
            <Doc>
                Whether this level is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Attribute name="attribute" required="true">
            <Doc>
                Source attribute of this Level. Required. Must be an attribute
                in this Dimension.
            </Doc>
        </Attribute>
        <Attribute name="parentAttribute" required="false">
            <Doc>
                The name of the Attribute that references the ID of the parent
                member in a parent-child hierarchy.
            </Doc>
        </Attribute>
        <Attribute name="nullParentValue" required="false">
            <Doc>
                Value which identifies null members of this Attribute.
                Used when defining a parent-child attribute.
                Typical values are 'NULL' and '0'.
            </Doc>
        </Attribute>
        <Attribute name="hideMemberIf" default="Never">
            <Doc>
                Condition which determines whether a member of this level
                is hidden. If a hierarchy has one or more levels with hidden
                members, then it is possible that not all leaf members are the
                same distance from the root, and it is termed a <dfn>ragged
                hierarchy</dfn>.

                <p>Allowable values are:
                <code>Never</code> (a member always appears; the default);
                <code>IfBlankName</code> (a member doesn't appear if its name
                is null, empty or all whitespace); and
                <code>IfParentsName</code> (a member appears unless its name
                matches the parent's.</p>
            </Doc>
            <Value>Never</Value>
            <Value>IfBlankName</Value>
            <Value>IfParentsName</Value>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                Name of a formatter class for the member labels being displayed.
                The class must implement the mondrian.spi.MemberFormatter
                interface.

                <p>This attribute is deprecated. Please use a nested
                MemberFormatter element.</p>
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the level's name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this level.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Array name="childArray" type="LevelElement">
            <Doc>
                Child elements of a Level.
                Closure can appear at most once.
                Annotations can appear at most once.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return first(name, attribute);
            }
            private static final LevelElement[] EMPTY = {};
            public final Children<LevelElement> children =
                new Children<LevelElement>(
                    LevelElement.class,
                    Closure.class,
                    Annotations.class)
                {
                    LevelElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(LevelElement[] ts) {
                        childArray = ts;
                    }
                };
            public Closure getClosure() {
                return children.singleton(Closure.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="Closure" class="LevelElement">
        <Doc>
            <p>Specifies the transitive closure of a parent-child hierarchy.
            Optional, but recommended for better performance.
            The closure is provided as a set of (parent, child) pairs:
            since it is the transitive closure these are actually (ancestor,
            descendant) pairs.</p>
            <p>Each row of the table must be a tuple of the parent-child
            hierarchy.</p>
        </Doc>
        <Attribute name="parentColumn" required="true">
            <Doc>
                <p>The column of the closure table which contains the key
                of the parent member of the parent-child tuple.</p>
            </Doc>
        </Attribute>
        <Attribute name="childColumn" required="true">
            <Doc>
                <p>The column of the closure table which contains the key
                of the child member of the parent-child tuple.</p>
            </Doc>
        </Attribute>
        <Attribute name="distanceColumn" required="false" default="distance">
            <Doc>
                <p>The column of the closure table which contains the number,
                in relative descendance count, of generations covered by the
                parent-child tuple.</p>
                <p>For example, In the relation
                A &lt; B &lt; C where A is the root and C is a grandchildren, the
                closure table should contain:</p>
                <code>
PARENT&#160;&#160;&#160;&#160;CHILD&#160;&#160;&#160;&#160;DISTANCE<br/>
&#160;&#160;0&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;A&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1<br/>
&#160;&#160;A&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;B&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1<br/>
&#160;&#160;A&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;2<br/>
&#160;&#160;B&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1<br/>
</code>
            </Doc>
        </Attribute>
        <Attribute name="table" required="true">
            <Doc>
	            <p>The name of the table to use as a closure table. The table
	            must be defined as part of the <code>PhysicalSchema</code>
	            section of the schema.</p>
            </Doc>
        </Attribute>
    </Element>

    <Element type="Property" class="NamedElement,AttributeElement">
        <Doc>
            Member property.
        </Doc>
        <Attribute name="name">
            <Doc>
                Name of this property. Defaults to name of attribute.
            </Doc>
        </Attribute>
        <Attribute name="attribute" required="true">
            <Doc>
                Source attribute of this Property.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the Property's name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this Property.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                <p>Name of a formatter class for the appropriate property value
                being displayed.</p>

                <p>The class must implement the mondrian.spi.PropertyFormatter
                interface.</p>

                <p>This attribute is deprecated. Please use a nested
                PropertyFormatter element.</p>
            </Doc>
        </Attribute>
        <Array name="childArray" type="PropertyElement">
            <Doc>
                Child elements of a Property. PropertyFormatter and Annotations
                can appear at most once, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return first(name, attribute);
            }
            private static final PropertyElement[] EMPTY = {};
            public final Children<PropertyElement> children =
                new Children<PropertyElement>(
                    PropertyElement.class,
                    PropertyFormatter.class,
                    Annotations.class)
                {
                    PropertyElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(PropertyElement[] ts) {
                        childArray = ts;
                    }
                };
            public PropertyFormatter getFormatter() {
                return children.singleton(PropertyFormatter.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="MeasureOrRef" class="NamedElement" abstract="true">
    </Element>

    <Element type="MeasureRef" class="MeasureOrRef">
        <Doc>
            Specifies the column where the aggregation of a given measure is
            stored in the current aggregate table.

            <p>Can only occur in a MeasureGroup whose type is 'aggregate'.</p>
        </Doc>
        <Attribute name="name" required="true">
            <Doc>Name of the referenced measure.</Doc>
        </Attribute>
        <Attribute name="aggColumn" required="true">
            <Doc>
                Column where the aggregation is stored.
            </Doc>
        </Attribute>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Measure" class="MeasureOrRef">
        <Attribute name="name" required="true">
            <Doc>Name of this measure.</Doc>
        </Attribute>
        <Attribute name="column" required="false">
            <Doc>
                Column that is source of this measure's values.
            </Doc>
        </Attribute>
        <Attribute name="table" required="false">
            <Doc>
                Table that contains column.
            </Doc>
        </Attribute>
        <Attribute name="formatString">
            <Doc>
                Format string with which to format cells of this measure. For
                more details, see the <a href="api/mondrian/util/Format.html">mondrian.util.Format</a> class.
            </Doc>
        </Attribute>
        <Attribute name="datatype">
            <Doc>
                Datatype of this measure. Valid values are 'String', 'Numeric',
                'Integer', 'Boolean', 'Date', 'Time' and 'Timestamp'.

                <p/>The default datatype of a measure is
                'Integer' if the measure's aggregator is 'count' or
                'distinct-count'; otherwise it is 'Numeric'.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="aggregator" required="true">
            <Doc>
                Aggregation function. Allowed values are "sum", "count", "min",
                "max", "avg", and "distinct-count". ("distinct count" is allowed
                for backwards compatibility, but is deprecated because XML
                enumerated attributes in a DTD cannot legally contain spaces.)
            </Doc>
        </Attribute>
        <Attribute name="formatter" required="false">
            <Doc>
                <p>Name of a formatter class for the appropriate cell being
                displayed.</p>

                <p>The class must implement the
                mondrian.spi.CellFormatter interface.</p>

                <p>This attribute is deprecated. Please use a nested
                CellFormatter element.</p>
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this measure.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean" required="false">
            <Doc>
                Whether this member is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Array name="childArray" type="MeasureElement">
            <Doc>
                Child elements of a Measure. Arguments and Annotations can
                appear at most once, CalculatedMemberProperty and
                CellFormatter can occur zero or more times, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final MeasureElement[] EMPTY = {};
            public final Children<MeasureElement> children =
                new Children<MeasureElement>(
                    MeasureElement.class,
                    Arguments.class,
                    Annotations.class,
                    CalculatedMemberProperty.class,
                    CellFormatter.class)
                {
                    MeasureElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(MeasureElement[] ts) {
                        childArray = ts;
                    }
                };
            public NamedList<CalculatedMemberProperty> getCalculatedMemberProperties() {
                return children.filterNamed(CalculatedMemberProperty.class);
            }
            public Arguments getArguments() {
                return children.singleton(Arguments.class);
            }
            public CellFormatter getCellFormatter() {
                return children.singleton(CellFormatter.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="CalculatedMembers" class="Holder,CubeElement">
        <Doc>
            Collection of CalculatedMember elements.
        </Doc>
        <Array name="array" type="CalculatedMember"/>
        <Code>
            <![CDATA[
            private static final CalculatedMembers EMPTY;
            static {
                EMPTY = new CalculatedMembers();
                EMPTY.array = new CalculatedMember[0];
            }
            public CalculatedMembers copy() {
                CalculatedMembers c = new CalculatedMembers();
                c.array = array.clone();
                return c;
            }
            public NamedList<CalculatedMember> list() {
                return new NamedListImpl<CalculatedMember>(
                    new MutableArrayList<CalculatedMember>() {
                        protected CalculatedMember[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(CalculatedMember[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="CalculatedMember" class="NamedElement">
        <Attribute name="name" required="true">
            <Doc>
                Name of this calculated member.
            </Doc>
        </Attribute>
        <Attribute name="formatString">
            <Doc>
                Format string with which to format cells of this member. For
                more details, see {@link mondrian.util.Format}.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the name.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this calculated member.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="formula" required="false">
            <Doc>
                MDX expression which gives the value of this member.
                Equivalent to the Formula sub-element.
            </Doc>
        </Attribute>
        <Attribute name="dimension" required="false">
            <Doc>
                <p>Name of the dimension that this member belongs to.</p>
                <p>Deprecated: use {@code hierarchy} attribute instead.</p>
            </Doc>
        </Attribute>
        <Attribute name="hierarchy" required="false">
            <Doc>
                <p>Name of the hierarchy that this member belongs to.</p>
            </Doc>
        </Attribute>
        <Attribute name="parent" required="false">
            <Doc>
                Fully-qualified name of the parent member.
                If not specified, the member will be at the lowest level
                (besides the 'all' level) in the hierarchy.
            </Doc>
        </Attribute>
        <Attribute name="visible" type="Boolean" required="false">
            <Doc>
                Whether this member is visible in the user-interface.
                Default true.
            </Doc>
        </Attribute>
        <Array name="childArray" type="CalculatedMemberElement">
            <Doc>
                Child elements of a NamedSet. Formula, CellFormatter and
                Annotations can occur at most once; CalculatedMemberProperty can
                occur zero or more times, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final CalculatedMemberElement[] EMPTY = {};
            public final Children<CalculatedMemberElement> children =
                new Children<CalculatedMemberElement>(
                    CalculatedMemberElement.class,
                    Annotations.class,
                    CalculatedMemberProperty.class,
                    CellFormatter.class,
                    Formula.class)
                {
                    CalculatedMemberElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(CalculatedMemberElement[] ts) {
                        childArray = ts;
                    }
                };
            public Formula getFormula() {
                return children.singleton(Formula.class);
            }
            public CellFormatter getCellFormatter() {
                return children.singleton(CellFormatter.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            public NamedList<CalculatedMemberProperty> getCalculatedMemberProperties() {
                return children.filterNamed(CalculatedMemberProperty.class);
            }
            ]]>
        </Code>
    </Element>

    <Element type="CalculatedMemberProperty" class="NamedElement,MeasureElement,CalculatedMemberElement">
        <Doc>
            Property of a calculated member defined against a cube.
            It must have either an expression or a value.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this member property.
            </Doc>
        </Attribute>
         <Attribute name="caption" required="false">
            <Doc>
                A string being displayed instead of the name of this calculated
                member property.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this calculated member property.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="expression">
            <Doc>
                MDX expression which defines the value of this property.
                If the expression is a constant string, you could enclose it in
                quotes, or just specify the 'value' attribute instead.
            </Doc>
        </Attribute>
        <Attribute name="value">
            <Doc>
                Value of this property.
                If the value is not constant, specify the 'expression' attribute
                instead.
            </Doc>
        </Attribute>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            ]]>
        </Code>
    </Element>

    <Element type="NamedSets" class="Holder,CubeElement">
        <Doc>
            Collection of NamedSet elements.
        </Doc>
        <Array name="array" type="NamedSet"/>
        <Code>
            <![CDATA[
            private static final NamedSets EMPTY;
            static {
                EMPTY = new NamedSets();
                EMPTY.array = new NamedSet[0];
            }
            public NamedSets copy() {
                NamedSets c = new NamedSets();
                c.array = array.clone();
                return c;
            }
            public NamedList<NamedSet> list() {
                return new NamedListImpl<NamedSet>(
                    new MutableArrayList<NamedSet>() {
                        protected NamedSet[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(NamedSet[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="NamedSet" class="NamedElement,SchemaElement">
        <Doc><![CDATA[
            <p>Defines a named set which can be used in queries in the
            same way as a set defined using a WITH SET clause.</p>

            <p>A named set can be defined against a particular cube,
            or can be global to a schema. If it is defined against a
            cube, it is only available to queries which use that cube.</p>

            <p>A named set defined against a schema is available in
            all cubes in that schema. However, it is
            only valid if the cube contains dimensions with the names
            required to make the formula valid.</p>]]>

        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this named set.
            </Doc>
        </Attribute>
        <Attribute name="caption" required="false">
            <Doc>
                Caption of this named set.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this named set.
                Can be localized from Properties file using #{propertyname}.
            </Doc>
        </Attribute>
        <Attribute name="formula" required="false">
            <Doc>
                MDX expression which gives the value of this set.
                Equivalent to the Formula sub-element.
            </Doc>
        </Attribute>
        <Array name="childArray" type="CalculatedMemberElement">
            <Doc>
                Child elements of a CalculatedMember. Formula and Annotations
                can occur at most once; CalculatedMemberProperty can occur zero
                or more times, in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            private static final CalculatedMemberElement[] EMPTY = {};
            public final Children<CalculatedMemberElement> children =
                new Children<CalculatedMemberElement>(
                    CalculatedMemberElement.class,
                    Annotations.class,
                    CalculatedMemberProperty.class,
                    Formula.class)
                {
                    CalculatedMemberElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(CalculatedMemberElement[] ts) {
                        childArray = ts;
                    }
                };
            public Formula getFormula() {
                return children.singleton(Formula.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            public NamedList<CalculatedMemberProperty> getCalculatedMemberProperties() {
                return children.filterNamed(CalculatedMemberProperty.class);
            }
            ]]>
        </Code>
    </Element>

    <Element type="Formula" class="CalculatedMemberElement,NamedSetElement">
        <CData/>
    </Element>

    <Class class="PhysicalSchemaElement">
        <Doc>
            An element that can occur in a PhysicalSchema. A relation (such as
            a Table or View) or a Link.
        </Doc>
    </Class>

    <Class class="Relation" superclass="PhysicalSchemaElement">
        <Doc>
            A relation (table, inline table, or view) in a PhysicalSchema.
        </Doc>
        <Code>
            public abstract String getAlias();
        </Code>
    </Class>

    <Element type="Query" class="Relation">
        <Doc>
            Relation defined by a SQL statement.
        </Doc>
        <Attribute name="alias" required="true">
            <Doc>
                Alias to be used with this SQL expression when it is used to
                form queries. Must be specified.
            </Doc>
        </Attribute>
        <Attribute name="keyColumn">
            <Doc>
                Name of the column that forms this query's key.
                Equivalent to a Key child containing a single Column.
            </Doc>
        </Attribute>
        <Array name="childArray" type="QueryElement">
            <Doc>
                Child elements.
                Key can occur multiple times.
                Annotations can each occur at most once.
                ExpressionView must occur once.
            </Doc>
        </Array>
        <Code><![CDATA[
            public String getAlias() {
                return alias;
            }
            private static final QueryElement[] EMPTY = {};
            public final Children<QueryElement> children =
                new Children<QueryElement>(
                    QueryElement.class,
                    Key.class,
                    ExpressionView.class,
                    Annotations.class)
                {
                    QueryElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(QueryElement[] ts) {
                        childArray = ts;
                    }
                };
            public List<Key> getKeys() {
                return children.filter(Key.class);
            }
            public ExpressionView getExpressionView() throws Missing {
                return children.requiredSingleton(this, ExpressionView.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
        ]]>
        </Code>
    </Element>

    <Class class="QueryElement">
        <Doc>
            Child element of a Query.
        </Doc>
    </Class>

    <Element type="SQL" contentModel="mixed">
        <Attribute name="dialect" required="true" default="generic">
            <Doc>
                Dialect of SQL the view is intended for. Valid values include,
                but are not limited to:
                <ul>
                <li>generic</li>
                <li>access</li>
                <li>db2</li>
                <li>derby</li>
                <li>firebird</li>
                <li>hsqldb</li>
                <li>mssql</li>
                <li>mysql</li>
                <li>oracle</li>
                <li>postgres</li>
                <li>sybase</li>
                <li>teradata</li>
                <li>ingres</li>
                <li>infobright</li>
                <li>luciddb</li>
                <li>vertica</li>
                </ul>
            </Doc>
        </Attribute>
        <Any/>
        <Code><![CDATA[
            public int hashCode() {
                return dialect.hashCode();
            }

            public boolean equals(Object obj) {
                if (!(obj instanceof SQL)) {
                    return false;
                }
                SQL that = (SQL) obj;
                return this.dialect.equals(that.dialect) &&
                        Util.equals(this.getCData(), that.getCData());
            }

            /**
             * Sets the contents of this node to a single piece of text.
             */
            public void setCData(String cdata) {
                this.children =
                    new NodeDef[] {
                        new org.eigenbase.xom.TextDef(cdata)};
            }

            /**
             * Returns the concatenation of all text elements under this node.
             */
            public String getCData() {
                StringBuilder buf = new StringBuilder();
                for (org.eigenbase.xom.NodeDef child : children) {
                    buf.append("x");
                }
                return buf.toString();
            }

            /**
             * Converts an array of SQL to a
             * {@link mondrian.rolap.sql.SqlQuery.CodeSet} object.
             */
            public static SqlQuery.CodeSet toCodeSet(SQL[] sqls) {
                SqlQuery.CodeSet codeSet = new SqlQuery.CodeSet();
                for (SQL sql : sqls) {
                    codeSet.put(sql.dialect, sql.getCData());
                }
                return codeSet;
            }

            /**
             * Chooses the SQL that most closes matches the given dialect,
             * returning the generic SQL if there is no match.
             */
            public static SQL choose(SQL[] sqls, mondrian.spi.Dialect dialect) {
                String best = SqlQuery.getBestName(dialect);
                SQL genericSql = null;
                for (SQL sql : sqls) {
                    if (sql.dialect.equals(best)) {
                        return sql;
                    }
                    if (sql.dialect.equals("generic")) {
                        genericSql = sql;
                    }
                }
                if (genericSql == null) {
                    throw Util.newError("View has no 'generic' variant");
                }
                return genericSql;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Table" class="Relation">
        <Attribute name="name" required="true"/>
        <Attribute name="schema">
            <Doc>
                Optional qualifier for <code>table</code>.
            </Doc>
        </Attribute>
        <Attribute name="alias">
            <Doc>
                Alias to be used with this table when it is used to
                form queries. If not specified, defaults to the table
                name, but in any case, must be unique within the
                schema. (You can use the same table in different
                hierarchies, but it must have different aliases.)
            </Doc>
        </Attribute>
        <Attribute name="keyColumn">
            <Doc>
                Name of the column that forms this table's key.
                Equivalent to a Key child containing a single Column.
            </Doc>
        </Attribute>
        <Array name="childArray" type="TableElement">
            <Doc>
                Child elements of this Table.

                <p>ColumnDefs (optional):
                    Array of columns of this table.
                    Columns may be present only if the table is part of a
                    PhysicalSchema. They may be regular or calculated.</p>

                <p>Key (optional):
                    Array of references to the columns that form the primary key
                    of this table. </p>

                <p>Hints (optional):
                    Table optimization hints; may be ignored by dialect. </p>
            </Doc>
        </Array>
        <Code><![CDATA[
            public String getAlias() {
                return (alias != null) ? alias : name;
            }
            private static final TableElement[] EMPTY = {};
            public final Children<TableElement> children =
                new Children<TableElement>(
                    TableElement.class,
                    ColumnDefs.class,
                    Key.class,
                    Hints.class)
                {
                    TableElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(TableElement[] ts) {
                        childArray = ts;
                    }
                };
            public List<RealOrCalcColumnDef> getColumnDefs() {
                return children.only(ColumnDefs.EMPTY).list();
            }
            public List<Key> getKeys() {
                return children.filter(Key.class);
            }
            public List<Hint> getHints() {
                return children.only(Hints.EMPTY).list();
            }
        ]]></Code>
    </Element>

    <Element type="Hints" class="Holder,TableElement">
        <Doc>
            Collection of hints.
        </Doc>
        <Array name="array" type="Hint"/>
        <Code><![CDATA[
            private static final Hints EMPTY;
            static {
                EMPTY = new Hints();
                EMPTY.array = new Hint[0];
            }
            public Hints copy() {
                Hints c = new Hints();
                c.array = array.clone();
                return c;
            }
            public List<Hint> list() {
                return new MutableArrayList<Hint>() {
                    protected Hint[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(Hint[] ts) {
                        array = ts;
                    }
                };
            }
        ]]></Code>
    </Element>

    <Element type="Hint">
        <Doc>
            Dialect-specific table optimization hints.
        </Doc>
        <Attribute name="type" required="true">
            <Doc>
                Type of hint, interpreted and applied on a per-dialect basis.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <Element type="InlineTable" class="Relation">
        <attribute name="alias" required="true"/>
        <Array name="childArray" type="InlineTableElement">
            <Doc>
                Child elements of this Table.

                <p>ColumnDefs (required):
                    Array of columns of this table.
                    Columns may be present only if the table is part of a
                    PhysicalSchema. They may be regular or calculated.</p>

                <p>Key (optional):
                    Array of references to the columns that form the primary key
                    of this table. </p>

                <p>Rows (required):
                    Rows in table. Maybe empty.</p>
            </Doc>
        </Array>
        <Code><![CDATA[
            public String getAlias() {
                return alias;
            }
            private static final InlineTableElement[] EMPTY = {};
            public final Children<InlineTableElement> children =
                new Children<InlineTableElement>(
                    InlineTableElement.class,
                    ColumnDefs.class,
                    Rows.class,
                    Key.class)
                {
                    InlineTableElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(InlineTableElement[] ts) {
                        childArray = ts;
                    }
                };
            public List<RealOrCalcColumnDef> getColumnDefs() {
                return children.only(ColumnDefs.EMPTY).list();
            }
            public List<Row> getRows() {
                return children.only(Rows.EMPTY).list();
            }
            public Key getKey() {
                return children.singleton(Key.class);
            }
        ]]></Code>
    </Element>

    <Element type="AutoGeneratedDateTable" class="Table">
        <Doc>
            Table for a time dimension that is automatically created and
            populated.

            <p>If the ColumnDefs child is specified, then columns are created
            with the given names and types. Each column must have a 'role'
            attribute that determines how it is populated.</p>

            <p>If ColumnDefs is not specified, the following columns
            will be created:
                time_id (role JULIAN, the Julian day number, e.g. 12345),
                the_date (role DATE, e.g. '2012-12-31', a DATE value or the DBMS
                    equivalent),
                the_day (role DAY_OF_WEEK_NAME, e.g. 'Wednesday'),
                the_month (role MONTH_NAME, e.g. 'December'),
                the_year (role YEAR, e.g. 2012),
                day_of_month (role DAY_OF_MONTH, e.g. '31'),
                week_of_year (role WEEK_OF_YEAR, e.g. 53),
                month_of_year (role MONTH, e.g. 12),
                quarter (role QUARTER, e.g. 4).</p>
        </Doc>
        <Attribute name="startDate" required="true">
            <Doc>The first date to add to the table.</Doc>
        </Attribute>
        <Attribute name="endDate" required="true">
            <Doc>The day after the last date to add to the table.</Doc>
        </Attribute>
    </Element>

    <Element type="ColumnDefs" class="Holder,TableElement,InlineTableElement">
        <Doc>
            Holder for an array of RealOrCalcColumnDef elements.
        </Doc>
        <Array name="array" type="RealOrCalcColumnDef"/>
        <Code>
            <![CDATA[
            private static final ColumnDefs EMPTY;
            static {
                EMPTY = new ColumnDefs();
                EMPTY.array = new RealOrCalcColumnDef[0];
            }
            public ColumnDefs copy() {
                ColumnDefs c = new ColumnDefs();
                c.array = array.clone();
                return c;
            }
            public List<RealOrCalcColumnDef> list() {
                return new MutableArrayList<RealOrCalcColumnDef>() {
                    protected RealOrCalcColumnDef[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(RealOrCalcColumnDef[] ts) {
                        array = ts;
                    }
                };
            }
            ]]>
        </Code>
    </Element>

    <Element type="RealOrCalcColumnDef" abstract="true">
        <Attribute name="name" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <Attribute name="type" required="false">
            <Doc>
                Type of the column. Valid values are
                String, Numeric, Integer, Boolean, Date, Time or Timestamp.

                <p>If not present, mondrian retrieves the type from the
                    underlying database.</p>
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
        </Attribute>
        <Attribute name="internalType" required="false">
            <Doc>
                Indicates the Java type that Mondrian uses to store this
                level's key column. It also determines the JDBC method that
                Mondrian will call to retrieve the column; for example, if the
                Java type is 'int', Mondrian will call 'ResultSet.getInt(int)'.

                <p/>Usually this attribute is not needed, because Mondrian can
                choose a sensible type based on the type of the database
                column.

                <p/>Allowable values are: 'int', 'long', 'Object', 'String'.
            </Doc>
        </Attribute>
    </Element>

    <Element type="ColumnDef" class="RealOrCalcColumnDef">
        <Doc>
            Column definition for a table or inline table.
        </Doc>
        <Object name="timeDomain" required="false" type="TimeDomain">
            <Doc>
                If this column is part of an auto-generated date dimension
                table, the rule to generate the values in the column.

                <p>Ignored if this column belongs to a non-generated table.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="TimeDomain">
        <Doc>
            Specification for how to generate the values of a column in an
            auto-generated time dimension table.
        </Doc>
        <Attribute name="role">
            <Doc>
                <p>Role of this column in an auto-generated time dimension
                    table. Valid values are 'JULIAN', 'YEAR', et cetera; see
                    {@link MondrianDef.AutoGeneratedDateTable} for the full list
                    of values.)</p>
            </Doc>
        </Attribute>
        <Attribute name="epoch">
            <Doc>
                <p>If role is 'julian', the date at which numbering starts.
                    By default, this is January 1, 4713 BC (per the definition
                    of Julian Day Number). Date is in the format
                    'yyyy-mm-dd'.</p>
            </Doc>
        </Attribute>
    </Element>

    <Element type="CalculatedColumnDef" class="RealOrCalcColumnDef">
        <Doc>
            Column definition that is computed using an expression.
        </Doc>
        <Object name="expression" type="Expression" required="true"/>
    </Element>

    <Element type="Rows" class="Holder,InlineTableElement">
        <Doc>
            Holder for an array of Row elements.
        </Doc>
        <Array name="array" type="Row"/>
        <Code>
            <![CDATA[
            private static final Rows EMPTY;
            static {
                EMPTY = new Rows();
                EMPTY.array = new Row[0];
            }
            public Rows copy() {
                Rows c = new Rows();
                c.array = array.clone();
                return c;
            }
            public List<Row> list() {
                return new MutableArrayList<Row>() {
                    protected Row[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(Row[] ts) {
                        array = ts;
                    }
                };
            }
            ]]>
        </Code>
    </Element>

    <Element type="Row">
        <Doc>
            Row definition for an inline table.
            Must have one Column for each ColumnDef in the InlineTable.
        </Doc>
        <Array name="values" type="Value"/>
    </Element>

    <Element type="Value">
        <Doc>
            Column value for an inline table.
            The CDATA holds the value of the column.
        </Doc>
        <Attribute name="column" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <!-- AggTable ======================================================= -->
    <Element type="AggTable">
        <Doc>
            A definition of an aggregate table for a base fact table.
            This aggregate table must be in the same schema as the
            base fact table.
        </Doc>
        <Attribute name="ignorecase" type="Boolean" required="false"
                default="true" >
            <Doc>
                Whether or not the match should ignore case.
            </Doc>
        </Attribute>
        <Object name="factcount" type="AggFactCount" required="true">
            <Doc>
                What does the fact_count column look like.
            </Doc>
        </Object>
        <Array name="ignoreColumns" type="AggIgnoreColumn"/>
        <Array name="foreignKeys" type="AggForeignKey"/>
        <Array name="measures" type="AggMeasure"/>
        <Array name="levels" type="AggLevel"/>
        <Code>
            public boolean isIgnoreCase() {
                return ignorecase.booleanValue();
            }
            public AggFactCount getAggFactCount() {
                return factcount;
            }
            public AggIgnoreColumn[] getAggIgnoreColumns() {
                return ignoreColumns;
            }
            public AggForeignKey[] getAggForeignKeys() {
                return foreignKeys;
            }
            public AggMeasure[] getAggMeasures() {
                return measures;
            }
            public AggLevel[] getAggLevels() {
                return levels;
            }
        </Code>
    </Element>

    <Element type="AggName" super="AggTable" class="NamedElement">
        <Attribute name="name" required="true">
            <Doc>
                The Table name of a Specific aggregate table.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
        </Code>
    </Element>

    <Element type="AggPattern" super="AggTable">
        <Attribute name="pattern" required="true">
            <Doc>
                A Table pattern used to define a set of aggregate tables.
            </Doc>
        </Attribute>
        <Array name="excludes" type="AggExclude"/>
        <Code>
            public String getPattern() {
                return pattern;
            }
            public AggExclude[] getAggExcludes() {
                return excludes;
            }
        </Code>
    </Element>

    <Element type="AggExclude" class="NamedElement">
        <Attribute name="pattern" required="false">
            <Doc>
                A Table pattern not to be matched.
            </Doc>
        </Attribute>
        <Attribute name="name" required="false">
            <Doc>
                The Table name not to be matched.
            </Doc>
        </Attribute>
        <Attribute name="ignorecase" type="Boolean" required="false"
                default="true" >
            <Doc>
                Whether or not the match should ignore case.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getPattern() {
                return pattern;
            }
            public boolean isIgnoreCase() {
                return ignorecase.booleanValue();
            }
        </Code>
    </Element>

    <Element type="AggColumnName" abstract="true">
        <Attribute name="column" required="true">
            <Doc>
                The name of the fact count column.
            </Doc>
        </Attribute>
        <Code>
            public String getColumnName() {
                return column;
            }
        </Code>
    </Element>

    <Element type="AggFactCount" class="AggColumnName"/>

    <Element type="AggIgnoreColumn" super="AggColumnName"/>

    <Element type="AggForeignKey">
        <Doc>
            The name of the column mapping from base fact table foreign key
            to aggregate table foreign key.
        </Doc>
        <Attribute name="factColumn" required="true">
            <Doc>
                The name of the base fact table foreign key.
            </Doc>
        </Attribute>
        <Attribute name="aggColumn" required="true">
            <Doc>
                The name of the aggregate table foreign key.
            </Doc>
        </Attribute>
        <Code>
            public String getFactFKColumnName() {
                return factColumn;
            }
            public String getAggregateFKColumnName() {
                return aggColumn;
            }
        </Code>
    </Element>
    <Element type="AggLevel" class="NamedElement">
        <Attribute name="column" required="true">
            <Doc>
                The name of the column mapping to the level name.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                The name of the Dimension Hierarchy level.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getColumnName() {
                return column;
            }
        </Code>
    </Element>

    <Element type="AggMeasure" class="NamedElement">
        <Attribute name="column" required="true">
            <Doc>
                The name of the column mapping to the measure name.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                The name of the Cube measure.
            </Doc>
        </Attribute>
        <Code>
            public String getNameAttribute() {
                return name;
            }
            public String getColumn() {
                return column;
            }
        </Code>
    </Element>

    <!-- Columns and keys ================================================== -->
    <Element type="Columns" class="Holder">
        <Doc>
            Collection of columns.
        </Doc>
        <Array name="array" type="Column"/>
        <Code>
            <![CDATA[
            private static final Columns EMPTY;
            static {
                EMPTY = new Columns();
                EMPTY.array = new Column[0];
            }
            public Columns copy() {
                Columns c = new Columns();
                c.array = array.clone();
                return c;
            }
            public List<Column> list() {
                return new MutableArrayList<Column>() {
                    protected Column[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(Column[] ts) {
                        array = ts;
                    }
                };
            }
            protected static Column[] foo(String column, String table, Columns columns) {
                return columns != null ? columns.array.clone()
                    : column != null ? new Column[] {new Column(table, column)}
                    : null;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Key" class="Columns,TableElement,InlineTableElement,AttributeElement,QueryElement">
        <Doc>
            Definition of the key of a dimension or table.

            <p>Even though its base class is Columns, and Columns implements
            the Holder interface, we do not use Key as a holder. This is
            because a Table can have more than one Key.</p>
        </Doc>
        <Attribute name="name" required="false">
            <Doc>
                The name of this key.
                If no name is supplied, the key is named 'primary'.
                A table cannot have two keys of the same name.
                Dimension keys must not have names.
            </Doc>
        </Attribute>
    </Element>

    <Element type="Name" class="Columns,AttributeElement">
        <Doc>
            Column that holds the name of an attribute.
            See also <code>Attribute.nameColumn</code>.
        </Doc>
        <Code>
            <![CDATA[
            public static Name of(String column, String table, Name name) {
                Column[] columns = foo(column, table, name);
                if (columns == null) {
                    return null;
                }
                Name copy = new Name();
                copy.array = columns;
                return copy;
            }
            ]]>
        </Code>
    </Element>

    <Element type="OrderBy" class="Columns,AttributeElement">
        <Doc>
            Column(s) that define the order of members of an attribute.
            See also <code>Attribute.orderByColumn</code>.
        </Doc>
        <Code>
            <![CDATA[
            public static OrderBy of(String column, String table, OrderBy orderBy) {
                Column[] columns = foo(column, table, orderBy);
                if (columns == null) {
                    return null;
                }
                OrderBy copy = new OrderBy();
                copy.array = columns;
                return copy;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Caption" class="Columns,AttributeElement">
        <Doc>
            Column that holds the caption of an attribute.
            See also <code>Attribute.captionColumn</code>.
        </Doc>
        <Code>
            <![CDATA[
            public static Caption of(String column, String table, Caption caption) {
                Column[] columns = foo(column, table, caption);
                if (columns == null) {
                    return null;
                }
                Caption copy = new Caption();
                copy.array = columns;
                return copy;
            }
            ]]>
        </Code>
    </Element>

    <Element type="ForeignKey" class="Columns">
        <Doc>
            Column(s) that hold the foreign key from a measure group's
            fact table to a dimension's table.
            See also <code>ForeignKeyLink.foreignKeyColumn</code>.
        </Doc>
    </Element>

    <Element type="Arguments" class="Columns,MeasureElement">
        <Doc>
            Arguments to a measure. For most measures, the argument is a single
            Column. See also the <code>column</code> attribute of the Measure
            element.
        </Doc>
    </Element>

    <Class class="Expression"/>

    <Element type="Column" class="Expression">
        <Doc>
            Reference to a column in an expression, key, or CopyLink.

            <p>Table name is optional if the column is being used within a
                table definition. If the column reference is used within a key,
                the table name, if present, must be the same as the containing
                table.</p>
        </Doc>
        <Attribute name="table">
            <Doc>
                Alias of the table which contains this column. Not required if
                the query only has one table.
            </Doc>
        </Attribute>
        <Attribute name="name" required="true">
            <Doc>
                Name of the column.
            </Doc>
        </Attribute>
        <Attribute name="aggColumn" required="false">
            <Doc>
                Applicable only for columns in a CopyLink (part of the
                definition of an aggregate MeasureGroup), specifies the
                column in the aggregate table that corresponds to the given
                dimension table column.
            </Doc>
        </Attribute>
        <Code><![CDATA[
            /** Convenience constructor. */
            public Column(String table, String name) {
                this();
                Util.assertTrue(name != null);
                this.table = table;
                this.name = name;
            }
            ]]>
        </Code>
    </Element>

    <Element type="ExpressionView" class="Expression,QueryElement">
        <Doc>
            A collection of SQL expressions, one per dialect.
        </Doc>
        <Array name="expressions" type="SQL" min="1"/>
    </Element>

    <!-- Access control =================================================== -->
    <Element type="Role" class="SchemaElement,NamedElement">
        <Doc>
            A role defines an access-control profile. It has a series of grants
            (or denials) for schema elements.
        </Doc>
        <Attribute name="name" required="true"/>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implements this role.
                If specified, the class must implement either
                <code>mondrian.spi.Role</code> or
                <code>mondrian.spi.RoleGenerator</code>
                interface.

                <p>If specified, Role must not have Script, Union or SchemaGrant
                    children.</p>
            </Doc>
        </Attribute>
        <Array name="childArray" type="RoleElement">
            <Doc>
                Child elements of this Role.
                Script,
                Union (at most once),
                SchemaGrant,
                Annotations (at most once), in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
                public String getNameAttribute() { return name; }
                private static final RoleElement[] EMPTY = {};
                public final Children<RoleElement> children =
                    new Children<RoleElement>(
                        RoleElement.class,
                        Annotations.class,
                        SchemaGrant.class,
                        Union.class)
                    {
                        RoleElement[] getArray() {
                            return childArray == null ? EMPTY : childArray;
                        }
                        void setArray(RoleElement[] ts) {
                            childArray = ts;
                        }
                    };
            public List<SchemaGrant> getSchemaGrants() {
                return children.filter(SchemaGrant.class);
            }
            public Union getUnion() {
                return children.singleton(Union.class);
            }
            public Script getScript() {
                return children.singleton(Script.class);
            }
            public NamedList<Annotation> getAnnotations() {
                return children.only(Annotations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Class class="Grant">
        <Attribute name="access" required="true">
            <Doc>Values correspond to <code>Access</code>.</Doc>
            <Value>all</Value>
            <Value>custom</Value>
            <Value>none</Value>
            <Value>all_dimensions</Value>
        </Attribute>
    </Class>

    <Element type="SchemaGrant" class="Grant,RoleElement">
        <Doc>
            Grants (or denies) this role access to this schema.
            <code>access</code> may be "all", "all_dimensions", "custom"
            or "none".
            If <code>access</code> is "all_dimensions", the role has access
            to all dimensions but still needs explicit access to cubes.
            If <code>access</code> is "custom", no access will be inherited by
            cubes for which no explicit rule is set.
            If <code>access</code> is "all_dimensions", an implicut access is
            given to all dimensions of the schema's cubes, provided the cube's
            access attribute is either "custom" or "all".
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Schema, int)">mondrian.olap.Role#grant(mondrian.olap.Schema,int)</a>.
        </Doc>
        <Array name="cubeGrants" type="CubeGrant"/>
    </Element>

    <Element class="Grant" type="CubeGrant">
        <Doc>
            Grants (or denies) this role access to a cube.
            <code>access</code> may be "all", "custom" or "none".
            If <code>access</code> is "custom", no access will be inherited
            by the dimensions of this cube, unless the parent SchemaGrant is
            set to "ALL_DIMENSIONS".
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Cube, int)">mondrian.olap.Role#grant(mondrian.olap.Cube,int)</a>.
        </Doc>
        <Attribute name="cube" required="true">
            <Doc>The unique name of the cube</Doc>
        </Attribute>
        <Array name="dimensionGrants" type="DimensionGrant"/>
        <Array name="hierarchyGrants" type="HierarchyGrant"/>
    </Element>

    <Element class="Grant" type="DimensionGrant">
        <Doc>
            Grants (or denies) this role access to a dimension.
            <code>access</code> may be "all", "custom" or "none".
            Note that a role is implicitly given access to a dimension when it
            is given "ALL" acess to a cube.
            If <code>access</code> is "custom", no access will be inherited
            by the hierarchies of this dimension.
            If the parent schema <code>access</code> is "ALL_DIMENSIONS",
            this timension will inherit <code>access</code> "ALL".
            See also the "all_dimensions" option of the "SchemaGrant" element.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Dimension, int)">mondrian.olap.Role#grant(mondrian.olap.Dimension,int)</a>.
        </Doc>
        <Attribute name="dimension" required="true">
            <Doc>The unique name of the dimension</Doc>
        </Attribute>
    </Element>

    <Element class="Grant" type="HierarchyGrant">
        <Doc>
            Grants (or denies) this role access to a hierarchy.
            <code>access</code> may be "all", "custom" or "none".
            If <code>access</code> is "custom", you may also specify the
            attributes <code>topLevel</code>, <code>bottomLevel</code>, and
            the member grants.
            If <code>access</code> is "custom", the child levels of this
            hierarchy will not inherit access rights from this hierarchy,
            should there be no explicit rules defined for said child level.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Hierarchy, int, mondrian.olap.Level)">mondrian.olap.Role#grant(mondrian.olap.Hierarchy, int, mondrian.olap.Level)</a>.
        </Doc>
        <Attribute name="hierarchy" required="true">
            <Doc>The unique name of the hierarchy</Doc>
        </Attribute>
        <Attribute name="topLevel" required="false">
            <Doc>Unique name of the highest level of the hierarchy from which
            this role is allowed to see members. May only be specified if
            the <code>HierarchyGrant.access</code> is "custom". If not
            specified, role can see members up to the top level.</Doc>
        </Attribute>
        <Attribute name="bottomLevel" required="false">
            <Doc>Unique name of the lowest level of the hierarchy from which
            this role is allowed to see members. May only be specified if
            the <code>HierarchyGrant.access</code> is "custom". If not
            specified, role can see members down to the leaf level.</Doc>
        </Attribute>
        <Attribute name="rollupPolicy" required="false">
            <Doc>Policy which determines how cell values are calculated if
                not all of the children of the current cell are visible to
                the current role. Allowable values are 'full' (the default),
                'partial', and 'hidden'.</Doc>
        </Attribute>
        <Array name="memberGrants" type="MemberGrant"/>
    </Element>

    <Element type="MemberGrant">
        <Doc>
            Grants (or denies) this role access to a member.
            The children of this member inherit that access.
            You can implicitly see a member if you can see any of its children.
            See <a href="api/mondrian/olap/Role.html#grant(mondrian.olap.Member, int)">mondrian.olap.Role#grant(mondrian.olap.Member,int)</a>.
        </Doc>
        <Attribute name="member" required="true">
            <Doc>The unique name of the member</Doc>
        </Attribute>
        <Attribute name="access" required="true">
            <Value>all</Value>
            <Value>none</Value>
        </Attribute>
    </Element>

    <!-- Union ============================================================ -->
    <Element type="Union" class="Holder,RoleElement">
        <Doc>
            Body of a Role definition which defines a Role to be the union
            of several Roles. The RoleUsage elements must refer to Roles that
            have been declared earlier in this schema file.
        </Doc>
        <Array name="array" type="RoleUsage" required="true">
            <Doc>
                Role usages.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final Union EMPTY;
            static {
                 EMPTY = new Union();
                 EMPTY.array = new RoleUsage[0];
            }
            public Union copy() {
                Union c = new Union();
                c.array = array.clone();
                return c;
            }
            public List<RoleUsage> list() {
                return new MutableArrayList<RoleUsage>() {
                    protected RoleUsage[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(RoleUsage[] ts) {
                        array = ts;
                    }
                };
            }
            ]]>
        </Code>
    </Element>

    <!-- RoleUsage ======================================================== -->
    <Element type="RoleUsage">
        <Doc>
            Usage of a Role in a union Role.
        </Doc>
        <Attribute name="roleName" required="true"/>
    </Element>

    <!-- UserDefinedFunction ============================================== -->
    <Element type="UserDefinedFunction" class="NamedElement,SchemaElement">
        <Doc>
            A <code>UserDefinedFunction</code> is a function which
            extends the MDX language. It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/UserDefinedFunction.html">mondrian.spi.UserDefinedFunction</a>.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>Name with which the user-defined function will be referenced in MDX expressions.</Doc>
        </Attribute>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implements this user-defined function.
                If specified, the class must implement the
                <code>mondrian.spi.UserDefinedFunction</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this user-defined function.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
        <Code>
            <![CDATA[
                public String getNameAttribute() { return name; }
            ]]>
        </Code>
    </Element>

    <Element type="Parameter" class="NamedElement,SchemaElement">
        <Doc>
            A <code>Parameter</code> defines a schema parameter.
            It can be referenced from an MDX statement using the <code>ParamRef</code>
            function and, if not final, its value can be overridden.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of this parameter.
            </Doc>
        </Attribute>
        <Attribute name="description" required="false">
            <Doc>
                Description of this parameter.
            </Doc>
        </Attribute>
        <Attribute name="type" default="String" required="true">
            <Doc>
                Indicates the type of this parameter:
                String, Numeric, Integer, Boolean, Date, Time, Timestamp, or Member.
            </Doc>
            <Value>String</Value>
            <Value>Numeric</Value>
            <Value>Integer</Value>
            <Value>Boolean</Value>
            <Value>Date</Value>
            <Value>Time</Value>
            <Value>Timestamp</Value>
            <Value>Member</Value>
        </Attribute>
        <Attribute name="modifiable" type="Boolean" required="false" default="true">
            <Doc>
                If false, statement cannot change the value of this parameter;
                the parameter becomes effectively constant (provided that its default
                value expression always returns the same value).
                Default is true.
            </Doc>
        </Attribute>
        <Attribute name="defaultValue" type="String" required="false">
            <Doc>
                Expression for the default value of this parameter.
            </Doc>
        </Attribute>
        <Code>
            <![CDATA[
                public String getNameAttribute() { return name; }
            ]]>
        </Code>
    </Element>

    <Element type="Annotations" class="Holder,SchemaElement,CubeElement,DimensionElement,HierarchyElement,LevelElement,AttributeElement,MeasureElement,QueryElement,CalculatedMemberElement,RoleElement,PropertyElement">
        <Doc>Holder for an array of Annotation elements</Doc>
        <Array name="array" type="Annotation"/>
        <Code>
            <![CDATA[
            private static final Annotations EMPTY;
            static {
                EMPTY = new Annotations();
                EMPTY.array = new Annotation[0];
            }
            public Annotations copy() {
                Annotations c = new Annotations();
                c.array = array.clone();
                return c;
            }
            public NamedList<Annotation> list() {
                return new NamedListImpl<Annotation>(
                    new MutableArrayList<Annotation>() {
                        protected Annotation[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Annotation[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="Annotation" class="NamedElement">
        <Doc>
            User-defined property value.
        </Doc>
        <Attribute name="name" required="true">
            <Doc>
                Name of the annotation.
            </Doc>
        </Attribute>
        <CData/>
        <Code>
            <![CDATA[
            public String getNameAttribute() {
                return name;
            }
            ]]>
        </Code>
    </Element>

    <Element type="Script" class="RoleElement">
        <Doc>
            Script fragment to implement an SPI such as user-defined function,
            member formatter, cell formatter.
        </Doc>
        <Attribute name="language" required="false" default="JavaScript">
            <Doc>
                The language of the script. Must be a supported scripting
                language in the current JVM. See
                {@link javax.script.ScriptEngineManager}.
                Default value is 'JavaScript'.
            </Doc>
        </Attribute>
        <CData/>
    </Element>

    <Element type="CellFormatter" class="CalculatedMemberElement,MeasureElement">
        <Doc>
            Plugin that formats the values of cells.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/CellFormatter.html">mondrian.spi.CellFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this cell formatter.
                Must implement the <code>mondrian.spi.CellFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this cell formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="MemberFormatter" class="AttributeElement">
        <Doc>
            Plugin that formats members.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/MemberFormatter.html">mondrian.spi.MemberFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this member formatter.
                Must implement the <code>mondrian.spi.MemberFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this member formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="PropertyFormatter" class="PropertyElement">
        <Doc>
            Plugin that formats properties.
            It must be implemented by a Java
            class which implements the interface
            <a href="api/mondrian/spi/PropertyFormatter.html">mondrian.spi.PropertyFormatter</a>,
            or by a script.
        </Doc>
        <Attribute name="className" required="false">
            <Doc>
                Name of the class which implemenets this property formatter.
                Must implement the <code>mondrian.spi.PropertyFormatter</code>
                interface.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Attribute>
        <Object name="script" required="false" type="Script">
            <Doc>
                Script to implement this property formatter.

                <p>Either the "Script" element or the "className" attribute
                must be specified.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="Localization" class="SchemaElement">
        <Doc>
            Defines localization of this schema.
        </Doc>
        <Array name="childArray" type="LocalizationElement" required="false">
            <Doc>
                List of Locales and Translations.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final LocalizationElement[] EMPTY = {};
            public final Children<LocalizationElement> children =
                new Children<LocalizationElement>(
                    LocalizationElement.class,
                    Locales.class,
                    Translations.class)
                {
                    LocalizationElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(LocalizationElement[] ts) {
                        childArray = ts;
                    }
                };
            public List<Locale> getLocales() {
                return children.only(Locales.EMPTY).list();
            }
            public List<Translation> getTranslations() {
                return children.only(Translations.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Class class="LocalizationElement">
        <Doc>
            An element that can occur in a Localization.
        </Doc>
    </Class>

    <Element type="Locales" class="Holder,LocalizationElement">
        <Doc>
            Holder for one or more Locale elements.
        </Doc>
        <Array name="array" type="Locale">
            <Doc>
                Locales.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final Locales EMPTY;
            static {
                EMPTY = new Locales();
                EMPTY.array = new Locale[0];
            }
            public Locales copy() {
                Locales c = new Locales();
                c.array = array.clone();
                return c;
            }
            public NamedList<Locale> list() {
                return new NamedListImpl<Locale>(
                    new MutableArrayList<Locale>() {
                        protected Locale[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Locale[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="Locale" class="NamedElement">
        <Doc>
            Describes a locale supported by this schema.
        </Doc>
        <Attribute name="locale" required="true">
            <Doc>
                IETF language tag, for example "en" for English, "pt-BR" for
                Brazilian Portuguese, or "nan-Hant-TW" for Min Nan Chinese as
                spoken in Taiwan using traditional Han characters.
            </Doc>
        </Attribute>
        <Code>
            <![CDATA[
            public String getNameAttribute() { return locale; }
            ]]>
        </Code>
    </Element>

    <Element type="Translations" class="Holder,LocalizationElement">
        <Doc>
            Holder for one or more Translation elements.
        </Doc>
        <Array name="array" type="Translation">
            <Doc>
                Collection of Translation elements.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final Translations EMPTY;
            static {
                EMPTY = new Translations();
                EMPTY.array = new Translation[0];
            }
            public Translations copy() {
                Translations c = new Translations();
                c.array = array.clone();
                return c;
            }
            public NamedList<Translation> list() {
                return new NamedListImpl<Translation>(
                    new MutableArrayList<Translation>() {
                        protected Translation[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(Translation[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="Translation" class="NamedElement">
        <Doc>
            <p>Describes a Translation supported by this schema.
            The resource file is substituted with the locale.</p>

            <p>For example, given
            <code>&lt;Translation path='sales_resource_${locale}.properties'/&gt;</code>,
            if the current locale is 'fr-FR', Mondrian will look for a file
            named 'sales_resource_fr_FR.properties'.</p>
        </Doc>
        <Attribute name="path" required="true">
            <Doc>
                Path of resource file.
            </Doc>
        </Attribute>
        <Code>
            <![CDATA[
            public String getNameAttribute() { return path; }
            ]]>
        </Code>
    </Element>

    <Element type="PhysicalSchema" class="SchemaElement">
        <Doc>
            Definition of the set of tables, columns, and relationships
            that the cubes and dimensions in this schema are mapped onto.
        </Doc>
        <Array name="childArray" type="PhysicalSchemaElement" required="false">
            <Doc>
                List of tables, other relations, and links in this physical
                schema. The elements do not need to be in any particular order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final PhysicalSchemaElement[] EMPTY = {};
            public final Children<PhysicalSchemaElement> children =
                new Children<PhysicalSchemaElement>(
                    PhysicalSchemaElement.class)
                {
                    PhysicalSchemaElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(PhysicalSchemaElement[] ts) {
                        childArray = ts;
                    }
                };
            ]]>
        </Code>
    </Element>

    <Element type="Link" class="PhysicalSchemaElement">
        <Doc>
            Definition of a link between two tables.
        </Doc>
        <Attribute name="source" required="true">
            <Doc>
                Name of the referenced table.
                This table must have a primary key defined.
            </Doc>
        </Attribute>
        <Attribute name="target" required="true">
            <Doc>
                Name of the referencing table.
            </Doc>
        </Attribute>
        <Attribute name="key" required="false">
            <Doc>
                Name of the key in the referenced table.
                If not specified, assumes 'primary', which is also the name
                assigned to a key which is not explicitly named.
            </Doc>
        </Attribute>
        <Attribute name="foreignKeyColumn">
            <Doc>
                Name of the foreign key column in the referencing table.

                <p>This attribute is a shorthand form if the primary key of the
                referenced table has only one column. If you use this form, you
                must not specify the 'ForeignKey' element.</p>
            </Doc>
        </Attribute>
        <Object name="foreignKey" type="ForeignKey">
            <Doc>
                List of foreign key columns.

                <p>These columns must correspond in number, order, and type
                to the columns of the primary key of the referenced (source)
                table.</p>
            </Doc>
        </Object>
    </Element>

    <Element type="MeasureGroups" class="Holder,CubeElement">
        <Doc>
            Holder for one or more MeasureGroup elements.
        </Doc>
        <Array name="array" type="MeasureGroup">
            <Doc>
                Measure groups.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final MeasureGroups EMPTY;
            static {
                EMPTY = new MeasureGroups();
                EMPTY.array = new MeasureGroup[0];
            }
            public MeasureGroups copy() {
                MeasureGroups c = new MeasureGroups();
                c.array = array.clone();
                return c;
            }
            public NamedList<MeasureGroup> list() {
                return new NamedListImpl<MeasureGroup>(
                    new MutableArrayList<MeasureGroup>() {
                        protected MeasureGroup[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(MeasureGroup[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="MeasureGroup" class="NamedElement">
        <Doc>
            Collection of measures that reside in the same fact table.
        </Doc>
        <Attribute name="name" type="String">
            <Doc>
                Name of this measure group.

                <p>If not specified, defaults to name of table. Must be
                    unique within cube.</p>
            </Doc>
        </Attribute>
        <Attribute name="type" type="String" default="fact">
            <Doc>
                Whether this measure group is defining a fact or aggregate
                table. Valid values are 'fact' (the default) and 'aggregate'.

                <p>Aggregate measure groups can contain 'MeasureRef' and
                    'CopyLink' elements.</p>
            </Doc>
            <Value>fact</Value>
            <Value>aggregate</Value>
        </Attribute>
        <Attribute name="table" required="true" type="String">
            <Doc>
                Name of the table that is the source of the measures in this
                group.
            </Doc>
        </Attribute>
        <Attribute name="ignoreUnrelatedDimensions" type="Boolean" default="false">
            <Doc>
                If true, dimensions that are not related to measures in this
                measure group will be pushed to top level member.
            </Doc>
        </Attribute>
        <Attribute name="approxRowCount" required="false">
            <Doc>
                The estimated number of rows in this measure group's
                (fact or aggregate) table. Setting this property improves the
                performance of the aggregation optimizer and
                prevents it from issuing 'select count(*)'
                queries over the aggregation table.
            </Doc>
        </Attribute>
        <Array name="childArray" type="MeasureGroupElement">
            <Doc>
                Child elements of this MeasureGroup. These are Measures and
                DimensionLinks (once), in any order.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            /**
             * Returns whether this measure group represents an aggregate table
             * (or hybrid fact-aggregate), as opposed to a fact table.
             */
            public boolean isAggregate() {
                assert type == null
                    || type.equals("aggregate")
                    || type.equals("fact");
                return "aggregate".equals(type);
            }

            public String getNameAttribute() {
                return first(name, table);
            }

            private static final MeasureGroupElement[] EMPTY = {};
            public final Children<MeasureGroupElement> children =
                new Children<MeasureGroupElement>(
                    MeasureGroupElement.class,
                    Measures.class,
                    DimensionLinks.class)
                {
                    MeasureGroupElement[] getArray() {
                        return childArray == null ? EMPTY : childArray;
                    }
                    void setArray(MeasureGroupElement[] ts) {
                        childArray = ts;
                    }
                };
            public List<DimensionLink> getDimensionLinks() {
                return children.only(DimensionLinks.EMPTY).list();
            }
            public NamedList<MeasureOrRef> getMeasures() {
                return children.only(Measures.EMPTY).list();
            }
            ]]>
        </Code>
    </Element>

    <Element type="Measures" class="Holder,MeasureGroupElement">
        <Doc>
            Holder element for {@link MondrianDef.Measure} elements.
        </Doc>
        <Array name="array" type="MeasureOrRef">
            <Doc>
                Measures.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final Measures EMPTY;
            static {
                EMPTY = new Measures();
                EMPTY.array = new MeasureOrRef[0];
            }
            public Measures copy() {
                Measures c = new Measures();
                c.array = array.clone();
                return c;
            }
            public NamedList<MeasureOrRef> list() {
                return new NamedListImpl<MeasureOrRef>(
                    new MutableArrayList<MeasureOrRef>() {
                        protected MeasureOrRef[] getArray() {
                            return array == null ? EMPTY.array : array;
                        }
                        protected void setArray(MeasureOrRef[] ts) {
                            array = ts;
                        }
                    }
                );
            }
            ]]>
        </Code>
    </Element>

    <Element type="DimensionLinks" class="Holder,MeasureGroupElement">
        <Doc>
            Holder element for {@link MondrianDef.DimensionLink} elements.
        </Doc>
        <Array name="array" type="DimensionLink">
            <Doc>
                Dimension links.
            </Doc>
        </Array>
        <Code>
            <![CDATA[
            private static final DimensionLinks EMPTY;
            static {
                EMPTY = new DimensionLinks();
                EMPTY.array = new DimensionLink[0];
            }
            public DimensionLinks copy() {
                DimensionLinks c = new DimensionLinks();
                c.array = array.clone();
                return c;
            }
            public List<DimensionLink> list() {
                return new MutableArrayList<DimensionLink>() {
                    protected DimensionLink[] getArray() {
                        return array == null ? EMPTY.array : array;
                    }
                    protected void setArray(DimensionLink[] ts) {
                        array = ts;
                    }
                };
            }
            ]]>
        </Code>
    </Element>

    <Element type="DimensionLink" abstract="true">
        <Doc>
            Usage of a {@link MondrianDef.Dimension} by a
            {@link MondrianDef.MeasureGroup}. Describes how the fact table
            of the measure group is linked to the dimension table.

            <p>There are subclasses, describing particular ways of linking:
            ForeignKeyLink, FactLink, ReferenceLink, NoLink.</p>
        </Doc>
        <Attribute name="dimension" required="true">
            <Doc>
                Name of the dimension that is linked to this measure group.
            </Doc>
        </Attribute>
    </Element>

    <Element type="ForeignKeyLink" class="DimensionLink">
        <Doc>
            Dimension that is linked to a measure group by a foreign key
            from the fact table to the dimension table. This is the most
            common form of dimension link.

            <p>You may specify the foreign key using either the foreignKeyColumn
            attribute, or a nested ForeignKey element, but not both. The foreign
            key must contain the same number and type of columns as the key of
            the linked dimension's key attribute.</p>
        </Doc>
        <Attribute name="foreignKeyColumn">
            <Doc>
                Name of the foreign key column in the fact table.

                <p>This attribute is a shorthand form if the primary key of the
                dimension is simple (has only one column), and is the key of the
                leaf level of the dimension. If you use this form, you must not
                specify the 'ForeignKey' element.</p>
            </Doc>
        </Attribute>
        <Attribute name="attribute" required="false">
            <Doc>
                Name of the attribute in the dimension that is referenced by
                the foreign key. Not required; if not specified, the dimension's
                key attribute is used.
            </Doc>
        </Attribute>
        <Object name="foreignKey" type="ForeignKey" required="false">
            <Doc>
                Column in the fact table that links to this attribute (or
                columns, if the attribute has a compound key).

                <p/>This element should be omitted if you specify the
                'foreignKeyColumn' attribute.
            </Doc>
        </Object>
    </Element>

    <Element type="FactLink" class="DimensionLink">
        <Doc>
            Dimension that is trivially linked to a measure group because
            the dimension table is the fact table. This is also known as
            a 'degenerate dimension'.
        </Doc>
    </Element>

    <Element type="ReferenceLink" class="DimensionLink">
        <Doc>
            Dimension that is linked into a measure group via another dimension.
            Its key does not join to the fact table, as in a ForeignKeyLink, but
            instead joins to the key of a given attribute of a given dimension.
        </Doc>
        <Attribute name="viaAttribute"/>
        <Attribute name="viaDimension"/>
    </Element>

    <Element type="NoLink" class="DimensionLink">
        <Doc>
            Documents that a dimension is not linked to the current measure
            group.

            <p>If Schema.missingLink=ignore then this element is not
            necessary. However, we recommend that you use
            Schema.missingLink=warning (the default) and create explicit links
            for all dimensions.</p>
        </Doc>
    </Element>

    <Element type="CopyLink" class="DimensionLink">
        <Doc>
            Indicates dimension that is represented by key columns in the fact
            table; or rather, the aggregate table, since this kind of link may
            only be used in a MeasureGroup whose type is 'aggregate'.
        </Doc>
        <Array name="columnRefs" type="Column">
            <Doc>Columns from the given dimension that are present in this
                aggregate table.</Doc>
        </Array>
    </Element>

    <!--
    // TODO: Define ManyToManyDimensionLink extends DimensionLink.
    // "The dimension table is joined to
    // an intermediate fact table. The intermediate fact table is joined, in
    // turn, to an intermediate dimension table to which the fact table is
    // joined".
    -->

    <!--
    // TODO: Define ReferencedDimensionLink extends DimensionLink.
     // "The dimension table is joined to
    // an intermediate table, which in turn, is joined to the fact table."
    -->


</Model>

<!-- End MondrianSchema.xml -->
